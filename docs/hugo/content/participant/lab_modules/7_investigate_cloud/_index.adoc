---
license: MIT-0
copyright: Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
chapter: false
pre: 
next: 
prev: 
title: 7. Review Cloud Architecture
weight: 70
---

== Objectives

This lab module will walk through how the dispenser, webapp, and coupled services interact. It will go into level of detail specific for the workshop. If you would like to review more details, please reference the link:/presenter.html[Setting Up the Workshop] documentation for deeper insights. By then end of this module you will have:

* An understanding of the relationship between the dispenser (_thing_), your Cognito user, and the DynamoDB database tables that track and log dispenser activity and state.
* Seen how the dispenser _thing_ uses the https://docs.aws.amazon.com/iot/latest/developerguide/iot-device-shadows.html[Device Shadow Service for AWS IoT] to listen for requested state changes, and also uses it for processing a dispense _request_ and acknowledging a _dispense_ response.
* Tested a _dispense_ request/response operation and monitored what takes place in different scenarios.
* Reviewed dispenser activity from both the DynamoDB _EventsTable_ and also webapp logging.
* An understanding of how the webapp along with the API Lambda functions control how to give credits to others, as well as only initiating a dispense event when there sufficient credits.

== Steps to Complete

Follow each step in order and use the *Open for detailed step-by-step instructions* if required.

=== Understand the AWS IoT Thing, Cognito User, and DynamoDB Table Relationships

As a software-as-a-service (SaaS) environment, there needs to be a specific relationship between all of the resources to help enforce the security and operational controls of the actions. At a high level, for each user, this is how the resources are associated with each other:

.Relationship between services
[plantuml, Relationship_services, svg]
....
@startuml
!define AWSPuml https://raw.githubusercontent.com/awslabs/aws-icons-for-plantuml/v4.0/dist
!includeurl AWSPuml/AWSCommon.puml
!includeurl AWSPuml/InternetOfThings/IoTGeneric.puml
!includeurl AWSPuml/InternetOfThings/IoTCertificateManager.puml
!includeurl AWSPuml/InternetOfThings/IoTPolicy.puml
!includeurl AWSPuml/SecurityIdentityAndCompliance/Cognito.puml
!includeurl AWSPuml/Database/DynamoDBTable.puml

top to bottom direction
skinparam linetype polyline
hide stereotype

together {
    Cognito(cognito, "testuser", "Cognito User", "custom:dispenserId: 123")
    DynamoDBTable(db, "DispenserTable", "DynamoDB Table", "dispenserId: 123")
}
rectangle  "IoT Core" as iot  {
    IoTGeneric(thing, "123", "IoT Thing", "")
    IoTCertificateManager(cert, "0ff1ab3", "X.509 Certificate", "CN=123")
    IoTPolicy(policy, "DispenserAccess", "IoT Policy", "Limited Shadow Access")
}

thing <-> cert
cert <-> policy
iot <-right-> cognito : "thingName = dispenserId"
iot <-> db : thingName = partiton key
cognito <--> db : custom:dispenserId = partiton key
@enduml
....

Each thing has a unique X.509 client certificate for authentication allowing the dispenser to connect publish and subscribe to the MQTT topics specific for that dispenser. This authorization of MQTT topics comes from a common policy that uses substitution variables that read the _Common Name_ value (which is the dispenser Id). The relationship continues into a Cognito User attribute, `custom:dispenserId`, that is read for every API call. Finally, your dispenser has an entry in the DynamoDB _DispenserTable_ that tracks current the credit balance and also any in-flight or stale command operations.

From the browser tab opened to the AWS Console review the relationships by viewing your dispenser and user details in the following AWS services:

* *AWS IoT Core* - View your thing, the attached certificate details, and the policy associated with the certificate. Also, view the other security policy that is associated with your Cognito user (used to monitor update events).
* *Amazon Cognito* - From _Manage User Pools_, select the _workshop-users_, Users and Groups, then your select your username. Note the `custom:user` and `custom:dispenserId` attribute values.
* *Amazon DynamoDB* - From the _DispenserTable_ review the credits value for your dispenser via the _dispenserId_ sort key. From the _DispenserEvents_ table, query with the partition key equal to your dispenserId. As others start to create and operate their dispensers, filtering will limit to just your events.

{{%expand "Open for detailed step-by-step instructions" %}}

. From the browser tab opened to the AWS Console, click on the _Services_ menu dropdown (upper left next to AWS logo), and type in _iot core_, then click on _IoT Core_ when the drop-down populates. This will direct you the the AWS IoT Core service page.
+
TIP: During the workshop you will be changing from service to service quite often. When navigating to a different service via the _Service->SERVICENAME_, right-click on the service name and select "Open in a new tab" (or equivalent). This will have all the services referenced within a single browser window on separate tabs.
+
. Click on _Get Started_ to take you to the main page, then select _Manage_ from the left tab. Click on _Skip tour_. This will take you to the list of things. Either select your thing (same as dispenserId), or click on _Search things_, which is helpful for large amounts of items.
. From your things page, click on _Security_. This shows that you have a single X.509 certificate (long hash value) associated with your thing. Click on the certificate which will show details on it. Note that the *Subject* contains values that are parsed when the certificate is presented, and the value for _CN_ (Common Name) is value of the dispenserId. This is how we relate different resources together.
. To continue viewing the IoT relationship, from the Certificate page, click on _Policies_. This shows what IoT policies are associated with the certificate, and by relationship, to the thing. Click on the policy to view its content, which is a JSON document.
+
Notice that all of the resources use the substitution variable `${iot:Certificate.Subject.CommonName}` as part of the string. What this does is on a per-certificate connection, evaluates the _CommonName_, or _CN_, of the certificate and replaces it. This allows for a single policy to used by all the dispensers.
+
.Abbreviated DispenserLimitedAccess Policy
[source,json]
----
 {
  "Version": "2012-10-17",
  "Statement": [
    {
      "Condition": {
        "Bool": {
          "iot:Connection.Thing.IsAttached": [
            "true"
          ]
        }
      },
      "Action": [
        "iot:Connect"
      ],
      "Resource": [
        "arn:aws:iot:REGION:ACCOUNT:client/${iot:Connection.Thing.ThingName}"
      ],
      "Effect": "Allow"
    },
    {
      "Action": [
        "iot:Subscribe"
      ],
      "Resource": [
        "arn:aws:iot:REGION:ACCOUNT:topicfilter/$aws/things/${iot:Certificate.Subject.CommonName}/shadow/*",
        "arn:aws:iot:REGION:ACCOUNT:topicfilter/$aws/things/${iot:Certificate.Subject.CommonName}/cmd/${iot:Certificate.Subject.CommonName}"
      ],
      "Effect": "Allow"
    }
  ]
}
----
+
. Next, from the _Services_ menu, select Cognito, click _Manage User Pools_, and then click on the _workshop-users_ pool. This is the service that manages the user account you created from the webapp. Under _General Settings_ select _Users and groups_ to display all of the user account. Search for your username and click on it. At the bottom you will notice a couple `custom:` attributes. The first, `custom:group user` denotes that your account is a general user account (extra credit, check out the admin user). The second attribute, `custom:dispenserId` shows  your dispenserId value. These fields are passed whenever you make an API call from the webapp and used by the Lambda functions to validate what actions you are allowed to take.
. From the _Services_ menu navigate to DynamoDB, which contains the database tables. Select _Tables_ from the left menu, select the _DispenserTable_ name, then select Items from the right pane. This table holds a single record for each dispenser. This most important field is _credits_, and should correspond to the value in the webapp ("1" in the table is $1.00 in the webapp). This record is modified every time someone gives you credits, or whenever you issue a dispense operation.
. Finally, changes tables by selecting _DispenserEvents_ from the left pane. You will see all the various log entries for all dispensers. To view just your dispensers events, click on the _Scan_ dropdown and change to _Query_, the for `Partition key` enter your dispenser's value and click on _Start Search_.

{{% /expand%}}

=== Monitor Shadow Changes for a Simple Operation (change LED Status)

The https://docs.aws.amazon.com/iot/latest/developerguide/iot-device-shadows.html[Device Shadow Service for AWS IoT] is an always available service that can be used by things and applications to set and track the state of device. There are two main sections to the shadow document, the _desired_ state and the _reported_ state. In this workshop, our desired settings will originate from the webapp and the dispenser will act upon them and set the correct reported state.

.Shadow state changes
[plantuml, shadow state changes, svg]
....
@startuml
hide empty description
state "States Match" as match
match : desired == reported

state "Desired Updated" as desired
desired : Different than reported
desired : or desired exists and reported doesn't

state "Reported Updated" as reported
reported : Value does not exist in desired


[*] --> match
match -right-> desired : New or different\ndesired value
desired --> [*] : /delta\n/updated
desired -> match : values match

match -left-> reported : New reported value
reported -> [*] : /updated
reported -> match : Value removed
@enduml
....

To see this in action, from the AWS Console navigate to your thing in IoT Core, then select _Shadow_ which will show the current shadow. Note the `led` attribute in the _desired_ and _reported_ sections, which should be the same. Also notice the value for `version` in the metadata. This increments each time the shadow is updated. To show the shadow is working, use the webapp to change the state of the LED by either toggling or setting to the other state. You will see the value for `led` has changed in the shadow document, and `version` has incremented.

To see how the shadow works when the device is in a disconnected state, unplug the microcontroller from your laptop. Now, in the webapp change the state of the LED and notice that the _desired_ and _delta_ states show this new value,but that the _reported_ state is still what the dispenser was in before being disconnected. Plug the microcontroller back into your laptop. Once it has booted and connected AWS IoT, the LED will change to the _desired_ state value and the dispenser will update the _reported_ state. Since _desired_ and _reported_ states are the same, the _delta_ state for the LED is removed.

{{%expand "Open for detailed step-by-step instructions" %}}

NOTE: In this expanded details section, we will only use a small subset of the entire shadow document and hierarchy to show the _desired_, _reported_, and _delta_ sections.

. Navigate to IoT Core->Manage->Things->Your Thing->Shadow and review the shadow document. Note that the _desired_ and _reported_ sections are the same. This indicates that the device and requested state from the webapp are in sync. At the bottom of the shadow document review the value for `version` in the metadata. This increments each time the shadow is updated.
+
[source,json]
----
"desired": {
  "led": "off",
  "led_ring": {
    "count": 5,
    "color": "FF8000"
  }
},
"reported": {
  "led": "off",
  "led_ring": {
    "count": 5,
    "color": "FF8000"
  }
},
...
"version": 100
----
+
. From the webapp, toggle or change the state of the LED (in this example from _off_ to _on_). The webapp sets the _desired_ state of the shadow, the dispenser reads this value, turns on the LED, and modifies the _reported_ state to _on_. You may miss the update in the AWS Console, but check the metatdata and notice that the value for `version` has increased by at least 2 (once for the webapp setting the _desired_ state and once when the dispenser updated the _reported_ state).
+
[source,json]
----
"desired": {
  "led": "on",
  "led_ring": {
    "count": 5,
    "color": "FF8000"
  }
},
"reported": {
  "led": "on",
  "led_ring": {
    "count": 5,
    "color": "FF8000"
  }
},
...
"version": 102
----
+
. To see how the shadow works when the device is in a disconnected state, unplug the microcontroller from your laptop, then toggle or set the LED to the alternate state (in this case from _on_ to _off_). Notice that the _desired_ and _reported_ states are different, and that there is a _delta_ state which show only those differences. This is useful when you only want to focus on the changes between _desired_ and _reported_ states.
+
[source,json]
----
"desired": {
  "led": "off",
  "led_ring": {
    "count": 5,
    "color": "FF8000"
  }
},
"delta": {
  "led": "off",
},
"reported": {
  "led": "on",
  "led_ring": {
    "count": 5,
    "color": "FF8000"
  }
},
...
"version": 103
----
+
. To verify that the dispenser reads the shadow state upon restart, plug the dispenser back into your laptop and watch the shadow document. The dispenser will reconcile the states which will remove the attribute from the _delta_ section (or completely remove it).
+
[source,json]
----
"desired": {
  "led": "off",
  "led_ring": {
    "count": 5,
    "color": "FF8000"
  }
},
"reported": {
  "led": "off",
  "led_ring": {
    "count": 5,
    "color": "FF8000"
  }
},
...
"version": 105
----
{{% /expand%}}

=== Monitor Shadow  MQTT topics for a Complex Operation (Dispense Drink)

The shadow can also be used for more complex operations. While changing the state of the LED can tracked via a single attribute, operations such as dispensing a drink are more complex and considered a _request_/_response_ pattern. The webapp initiates the dispense operation as a _request_, and when the dispenser completes the operation it, in turn, sends a corresponding _response_. We use a short, random, `requestId` value to match the correlate the _request_ and _response_ operations.

.Tracking request/response using shadow
[plantuml, req_res_shadow, svg]
....
@startuml
!define AWSPuml https://raw.githubusercontent.com/awslabs/aws-icons-for-plantuml/v4.0/dist
!includeurl AWSPuml/AWSCommon.puml
!includeurl AWSPuml/InternetOfThings/IoTGeneric.puml
!includeurl AWSPuml/InternetOfThings/IoTShadow.puml
!includeurl AWSPuml/Compute/Lambda.puml
!includeurl AWSPuml/Database/DynamoDBTable.puml

hide footbox

IoTGenericParticipant(thing, 123, ) order 10
IoTShadowParticipant(shadow, 123, Device Shadow) order 20
LambdaParticipant(dispense, dispense.py, ) order 30
DynamoDBTableParticipant(db, DispenseTable, "pk=123") order 40

== Shadow Request/Response Empty BEFORE Dispense ==

dispense -> shadow : Add "request" object desired state
dispense -> db : Store requestId in dispenser's record
shadow -> thing : Publish to shadow /delta topic
thing -> thing : Dispense drink
thing -> shadow : Add "response" object to reported state
shadow -> dispense : Send shadow (via Rule)
db -> dispense : Read requestId and validate to "response"
dispense -> dispense : Dispense complete, delete both "request" and "response objects
dispense -> db : Delete requestId from dispenser's record

== Shadow Request/Response Empty AFTER Dispense ==
@enduml
....

As we cannot be sure that the dispenser is online, the webapp initiates the request and sets the _desired_ state of the shadow with a `request` object containing the `command` to execute, a unique `requestId`, and the `timestamp` of when the user clicked "Dispense a Drink" in the webapp.

To verify, ensure the microcontroller is connected and LED operations take place. Next, use  _Test_ from the IoT Core console and subscribe to the topic `$aws/things/dispenserId/shadow/#` (replace `dispenserId` with your value) to track all shadow operations. Next, from another tab or window, click the _Dispense!_ button (should still be green) to initiate a dispense operation. From the _MQTT Client_ tab, you should see a few shadow topic messages. Scroll through and review how the first message sets the `request` object, and after the dispenser completes turning the pump (indicated by the other LED on the controller board) the _reported_ state is updated with a `response` object that has the same `requestId`, and finally that the the `request` *and* `response` objects are both deleted from all shadow sections once the response has been reconciliated.

In this situation, we are using the shadow to track the status of a command sent to the dispenser, and the response once it acts upon it.

{{%expand "Open for detailed step-by-step instructions" %}}

. Ensure the microcontroller is connected and response to LED on/off events.
. Navigate to IoT Core->Test and in the _Subscription topic_ field, enter `$aws/things/dispenserId/shadow/#` (replace `dispenserId` with your value) and click _Subscribe to topic_.
. From the webapp, click the _Dispense!_ button (should still be green) to initiate a dispense operation. This should turn the other LED on the controller board on for a short period of time and create a few messages in the _MQTT Client_.
. Scroll to the bottom (oldest message) and look for the shadow update with _desired_ state that has the first `request` object.
+
[source,json]
----
{} initial request
----
+
. The next message by time will be the dispenser responding to the event publishing to the _reported_ state a `response` object with the same `requestId`, signifying that it has completed that request (either with a _success_ or _failed_ indicator).
+
[source,json]
----
{} request and response
----
. On the cloud side, the matching `request` and `response` objects trigger a Lambda function to log the transaction and clear out both objects from the shadow. This is essence reconciling the _request_ to the _response_, and readying the dispenser for its next operation.
+
[source,json]
----
{} cleared of both
----

{{% /expand%}}

=== Review Logging and Credits

We did something bad! We used up all of our credits testing the dispenser operation above. Each dispense operation costs $1.00, and has been deducted from our dispenser, as shown by the webapp. Navigate to the DynamoDB _DispenserTable_ and verify the credits match the webapp. Also, review the _EventsTable_ for your dispenser (review the first steps in this lab if needed) to see the various logging entries made while testing the LED and drink dispense test.

We use these tables as the _source of truth_ for the status of our dispenser. While the dispenser code you compiled and installed could be modified, a dispense operation only is created if there are sufficient credits in your account (e.g., DynamoDB DispenserTable entry). We use the relationship of the `dispenserId` in your user account via the webapp, associated with the same values in IoT Core and DynamoDB, to track the business logic we want to enforce in the overall SaaS application.

=== Webapp Overview

The webapp is your main interface for seeing the state of the dispenser via LEDs, and how to initiate a dispense action. As the webapp is running inside your local browser, there are two methods that can be used to track what is the current status. We can continuously https://en.wikipedia.org/wiki/Polling_(computer_science)[poll] via API to return the status, or use a https://en.wikipedia.org/wiki/Callback_(computer_programming)[callback] mechanism to alert the webapp when something has changed. In this case, the _callback_ method is used. It reduces the overall load on the SaaS service and demonstrates how we again use AWS IoT Core to facilitate this.

Modern web browsers have the ability to monitor what is running locally. Our webapp has additional debug, or `console.log()` statements to give an indication when something is happening. It does this b subscribing to the MQTT topics for your specific dispenser. From your browser, enable the _Web Console_ (name varies based on browser), and select the _Console_ tab. Now change the status of the LED. Every time you make a change, you will see an _Received MQTT message with change in LED or credit status_ message. This is alerted when an incoming MQTT message of interest such as a shadow update occurs.

These messages then trigger the webapp to make an API call requesting the complete status of the dispenser (LED status, credits, etc.), which in turn updates the main dispenser page. If there are no changes being made, no MQTT messages are generated, and subsequently, no API calls are made to request an update to the webapp.

{{%expand "Open for detailed step-by-step instructions" %}}

. Open the _Web Console_ for your browser:
.. FireFox: Select menu Tool->Web Developer->Web Console
.. Google Chrome: View->Developer->JavaScript Console
.. Internet Explorer 11: Either press the `F12` key or from the Setting Wheel->F12 Developer Tools->Console
.. Microsoft Edge: From upper right, select `...`->More tools->Developer tools->Console tab
.. Safari: Preferences->Advanced Tab->Show developer menu in menu bar (close Preferences), Develop->Show JavaScript Console
. Change the status of the LED with the dispenser connected. Notice the _Received MQTT message with change in LED or credit status_ lines. These a created when the webapp, which is subscribed to a set of MQTT topics receives a message. This is an indication that something may have changes and triggers the webapp to make an API call to the `/status` method, which returns the dispenser status parsed from the shadow document _and_ the DynamoDB _DispenserTable_.
. If there are no changes being made, no MQTT messages are generated, and subsequently, no API calls are made to request an update to the webapp.

{{% /expand%}}

=== Share the Love!

So far we have shown how the you interact with your dispenser via the webapp. Next, let's build our credits back up to a sufficient level to complete the rest of the lab. To do this, click on the _Share the Love!_ card underneath the LED status cards and follow the instructions. First, try giving credit to another dispenser number and monitor the _Last credit response_ message (with or without browser logging). Next, try to give yourself credits and note that the gray button to the right does not change to _SEND CREDIT!_. This is a constraint built into the webapp. However, even if you were to make a direct API call, the backend will also deny the request.

Finally, talk to you neighbor to either side of you and ask them to start sending you credits. You may alsop see that as the credits increase, the ring LED will also start to fill until you have at least $1.00, and after that the colors will changes as your balance goes above $2.00, $3.00, etc.

It is recommended that you have at least $2.00 or $3.00 to perform a couple dispenses with a fully built dispenser unit.

Good work!

== Checkpoints

Please ensure the following checkpoints are validated before moving on to the next module.

. The dispenser properly operates and toggles the LED status from the webapp
. A dispense operation enabled the _other_ LED on the controller board (motor control)
. You have an understanding of how the shadow document and DynamoDB tables are used to track the status of state (LEDs) and perform command and control (request/response) operations.

## Outcomes

Why do we use the shadow document for command and control, when it could also be done with regular MQTT messages? While either pattern are good practices, combining all of the operations into a single location makes it easier to follow for the workshop. As long as there is a way to track each request, the mechanism used doesn't matter.

One thing that we didn't discuss is the ring LED. In this case, it is used to give a visual indication of the credit levels. From the dispensers perspective, it is another shadow attribute set to manage. But instead of being set by clicking buttons in the webapp, this value is programmatically set by the cloud services whenever there is a change in the credit state of a dispenser. This demonstrates that functionality in not static and can be modified in either device (dispenser) or SaaS application (cloud-side).