[
{
	"uri": "https://cdd.example.com/docs/participant/lab_modules/1_overview.html",
	"title": "1. Architecture Overview",
	"tags": [],
	"description": "",
	"content": " Objectives In this initial lab, we will go through the overall architecture of the CDD. At the end of the lab, you will come away with the understanding of:\n The cloud components for interacting with the dispenser How user accounts, things, and database entries are interrelated How the dispenser updates local status ands responds to dispense commands  Steps to Complete 1. Overall Cloud Architecture When interacting with the cloud, the CDD utilizes two main paths, AWS IoT Core for MQTT communication and then a webapp with authentication to interact with the device and supporting databases.\n IoT Bi-Directional Communication - This section uses MQTT to communicate bi-directionally between the AWS cloud and the device. We also use MQTT to notify the webapp user when there have been activities. This eliminates the need for constant polling and only to query via API when there is information to update. API Logic - Most operations are completed via API calls. By using user authentication, each call can be verified to the specific dispenser via the AWS Lambda functionality. Webapp and Authentication/Authorization - This uses Amazon Cognito to authenticate users and provide a Jason Web Token (JWT) with signed attributes such as the corresponding drink dispenser id. The vended credentials are then use to make API calls and to establish a persistent connection to AWS IoT.  2. User and Dispenser Relationships For each individual user, there is a set of resources created and related during the user account creation process. A user, foo, authenticates with Cognito and is returned a signed JWT that contains information used by the webapp and API Gateway. For instance, user foo is associated with dispenserId of 123. Any API calls made use the dispenserId attribute to ensure that requests are only for the user\u0026rsquo;s dispenser and not someone elses. The value is also used to send and receive messages on specific MQTT topics so that one dispenser cannot be affected by another dispensers actions. This is a common field used throughout the backend cloud services.\n3. Dispenser Operations Your dispenser will only use MQTT to communicate with the cloud services. There are two main methods that a device uses to communicate. The first is through regular topics such as telem/123 where the device can subscribe to receive messages, or it can publish messages directly to the topic. In this case, telem indicates telemetry and normally would be messages sent from the device to the cloud.\nFor this workshop. we actually will use the shadow set of topics. This is a provided service of AWS IoT that tracks the state of a device. Each device has both a desired and reported state. It is common that cloud services would set the desired state, and the next time the device is online, it would read those values, set them locally, and update the reported state accordingly.\nA device can also use the delta state that tracks the difference between desired and reported states.\nThe shadow document will look similar to this:\n{ \u0026#34;desired\u0026#34;: { \u0026#34;led_ring\u0026#34;: { \u0026#34;count\u0026#34;: 0, \u0026#34;color\u0026#34;: \u0026#34;#FF00FF\u0026#34; }, \u0026#34;led\u0026#34;: \u0026#34;on\u0026#34;, \u0026#34;dispense_time_ms\u0026#34;: 4000, }, \u0026#34;reported\u0026#34;: { \u0026#34;led_ring\u0026#34;: { \u0026#34;count\u0026#34;: 0, \u0026#34;color\u0026#34;: \u0026#34;#FF00FF\u0026#34; }, \u0026#34;led\u0026#34;: \u0026#34;off\u0026#34;, \u0026#34;dispense_time_ms\u0026#34;: 2500, }, \u0026#34;delta\u0026#34;: { \u0026#34;led\u0026#34;: \u0026#34;on\u0026#34;, \u0026#34;dispense_time_ms\u0026#34;: 4000 } } In this example, there are two values that have been requested to be changed, led and dispense_time_ms, as reported by the delta state.\nFinally, there are AWS IoT Rules that are triggered upon the content of messages published. In the diagram above, the IoT rule is triggered when the shadow document changes, passing the details to a Lambda function that will write this to the Events database table.\nCheckpoints This module provides a high-level description of the various components used in the workshop. After completing this lab, you should have an understanding of:\n The differences between the physical dispenser and the webapp used to monitor and control it How Cognito and API Gateway are used by the webapp to issue commands or actions How the Dispenser uses MQTT for bi-directional command and control of the device using the Shadow service The differences between the Shadow document states (desired, reported, and delta)  As this lab is informational only, there are no specific checkpoints that need to be completed.\n"
},
{
	"uri": "https://cdd.example.com/docs/participant/lab_modules.html",
	"title": "Lab Modules",
	"tags": [],
	"description": "",
	"content": " Individual Module Overview There are various modules to complete in this workshop. Each module has a specific set of objects to complete, with the overall goal of the workshop being for you to build, program, and be able to dispense a drink. Each module is laid out in a similar manner:\n ObjectiveA short explanation of what you will be accomplishing, and why. StepsBoth high-level steps to complete the module, and a twirl-down with specific step-by-step instructions CheckpointA completed list of what comes from the objectives that needs to be validated before moving on to the next steps. Outcomes (optional)Depending upon the module, this section describes how the steps taken above help for the workshop or general AWS IoT development patterns.  Workshop Module List These are the labs to complete in order:\nTODO: Complete each bullet point lab\n Workshop overview and diagrams - Gavin - Understand relationship of user to dispenser, and AWS components used - completed Local laptop setup - Gavin - Install serial drivers and software to flash and monitor connected ESP32 - completed Create workshop user account - Gavin - Create account, log in, download and describe user details section Build ESP32 + Carrier - Gavin - Install ESP32 into carrier, connect via USB to laptop, verify monitor command works. This time will allow C9 to complete Build C9 development environment and compile code - Gavin - Clone repo and the pull in ESP IDP components to dispenser code, build code, download Flash and test - Anton - Verify that ESP32 starts up, connects, and provides validation of shadow. If not, move back to previous lab with hints Investigate app and AWS account - Gavin - From console, IoT subscribe to shadow then click on LED on/off/toggle, view operations. Click on dispense (with $1), note change of Neo pixel LEDs. Share the love and build up at least $1/$2 in credits. Build the dispenser - Anton - Complete hardware build with explanation of how different components work, and why. Test - Gavin - Use their dispenser or optionally pre-built ones.   1. Architecture Overview  Objectives In this initial lab, we will go through the overall architecture of the CDD. At the end of the lab, you will come away with the understanding of: The cloud components for interacting with the dispenser How user accounts, things, and database entries are interrelated How the dispenser updates local status ands responds to dispense commands Steps to Complete 1. Overall Cloud Architecture When interacting with the cloud, the CDD utilizes two main paths, AWS IoT Core for MQTT communication and then a webapp with authentication to interact with the device and supporting databases.\n 2. Laptop Setup  Objectives In this lab you will configure your laptop for the workshop. By the end of the module you will have: A directory or folder to hold all the files required for your dispenser. Installed and tested a device driver to communicate with the microcontroller. Downloaded a command line utility to program (flashed) the microcontroller. Have an open terminal or command prompt ready to issue commands. The microcontroller is programmed, or flashed, via a USB serial connection from a computer or laptop.\n 3. Create Account/Resources  ObjectivesThis lab module will walk though creation of user and account resources, and accessing your unique resources. By the end of the module you will have: Created and verify a user account.Understand what takes places during account creation.Know where to navigate in order to download and access your specific resources such as certificate and private key, and access other user details.Been introduced to UML sequence diagrams used to illustrate operations. Resource Creation ProcessWhen you first go through the user creation process, there are no resources created in advance.\n 4. MCU Setup \u0026amp; Test  Objectives This lab module will walk you through connecting the components to test the operation of the dispenser without having to build the entire dispenser at this time. By the end of this module you will have: Installed all the components needed to test the operation of the dispenser firmware with the cloud backend. Have an understanding of what each component does. Be able to communicate with the microcontroller via your laptop.\n 5. Cloud9 Development Environment  Objectives This lab module will walk you through how to launch the Cloud9 IDE and download the device firmware source code to modify and flash onto your drink dispenser. By the end of the module you will have: Installed the toolchain needed to compile and link the source code for the dispenser. Cloned the workshop repository which include the dispenser firmware source code. Installed the supporting tools needed to compile.\n 6. Flash \u0026amp; Test MCU  Objectives In this lab module, you will complete the configuration of the dispenser firmware, download the compiled files to your laptop, and then use the tools to flash the microcontroller. At that point, the main components of the dispenser with the exception of the motor, will be fully operational. By the end of the module you will have: Modified the base firmware code to work with your specific account.\n 7. Review Cloud Architecture  ObjectivesThis lab module will walk through how the dispenser, webapp, and coupled services interact. It will go into level of detail specific for the workshop. If you would like to review more details, please reference the Setting Up the Workshop documentation for deeper insights. By then end of this module you will have: An understanding of the relationship between the dispenser (thing), your Cognito user, and the DynamoDB database tables that track and log dispenser activity and state.\n 8. Build Dispenser  Objectives Statement of what and why we are doing this. Then more detailed list if needed. Steps to Complete Follow each step in order and use the Open for detailed step-by-step instructions if required. Specific action to complete Short description of what to do for experienced people Open for detailed step-by-step instructions detailed steps with markdown. Checkpoints Please ensure the following checkpoints are validated before moving on to the next module.\n 9. Dispense a Drink!  Objectives Okay, this is the moment of truth. You have: Setup your laptop to flash the dispenser. From Cloud9 compiled the firmware specific for your dispenser. Flashed and tested the cloud capabilities and built up enough credits to operate. Optionally built the dispenser and are ready to test. With all that completed, let\u0026rsquo;s dispenser a real liquid drink. Steps to Complete Follow each step in order and use the Open for detailed step-by-step instructions if required.\n "
},
{
	"uri": "https://cdd.example.com/docs/presenter/design_notes/message_flows.html",
	"title": "Message Flows",
	"tags": [],
	"description": "",
	"content": "Device and Application Message FlowsThe shadow document for devices tracks state of local resources. In the case of the motor board, this is led which maps to the second motor controller, which is not used. This give an indicator that things are working without having to activate the motor.\nThe led_ring is the round ring and count determine how many LED elements to light up, and the color is the RBG color for all active elements. Each of these below will always be in the desired state of the shadow and once online, in the reported state for the device.\n{ \u0026quot;led_ring\u0026quot;: { \u0026quot;count\u0026quot;: 0, \u0026quot;color\u0026quot;: \u0026quot;#RRGGBB\u0026quot; }, \u0026quot;led\u0026quot;: \u0026quot;on|off\u0026quot;, \u0026quot;dispense_time_ms\u0026quot;: 2500, } There are also a temporary request and response objects used to track command state. The cloud logic will create the request object in the desired state section of the shadow, and once processed by the device, it will create the response object in the reported state section. Finally, cloud logic will reconcile and clean up the shadow document of any entries left.\nBelow are what the request and response objects should look like. The command and requestId attribute and values must match. For the request object, the timestamp attribute is when the request was made, while in the response object it is when the dispenser completed the operation.\n{ \u0026quot;desired\u0026quot;: { \u0026quot;request\u0026quot;: { \u0026quot;command\u0026quot;: \u0026quot;dispense\u0026quot;, \u0026quot;requestId\u0026quot;: \u0026quot;1234-5678\u0026quot;, \u0026quot;timestamp\u0026quot;: 12345 } }, \u0026quot;reported\u0026quot;: { \u0026quot;response\u0026quot;: { \u0026quot;command\u0026quot;: \u0026quot;dispense\u0026quot;, \u0026quot;requestId\u0026quot;: \u0026quot;1234-5678\u0026quot;, \u0026quot;result\u0026quot;: \u0026quot;success\u0026quot;, \u0026quot;timestamp\u0026quot;: 45678 } }, } The following sequence diagrams show the flows for different uses. The first flows are device-to-cloud, then Rules Engine actions, and then API generated flows.\nDevice FlowsTurn on/off LEDUses the device shadow to set the desired state of an LED. The unused motor controller\u0026#8217;s associated LED can be set on or off, while the LED ring can be addressed with an RGB color and number of LEDs to light. All LED operations take place through the device shadow.\nAt creation, the LEDs are all set to a desired state of off. The dispenser hardware should read and honor the shadow settings for the LED.\nFigure 1. Turn on the LED In this flow:\nDispenser subscribes to shadow delta topic, e.g., $aws/things/123/shadow/deltaDispenser publishes desired state change to shadow update for led (LED for second motor controller)If there is a difference between desired and reported states, the delta, \"led\": \"on\" is sent to the dispenserDispenser enables the LED locallyDispenser then publishes teh reported state of LED1 to the shadow update topicRules engine matches update operation and invokes logging event action This is the same flow for led1 and led_ring. For led_ring, the attributes are the amount of LEDs to light (0-5) and the RBG color in hex, e.g., #ff0000 for full red.\nNote: The LED operation can be on or off.\n Activate DispenserUses the device\u0026#8217;s shadow desired state to send a command (request) to the dispenser. After the dispenser has completed the operation, it updates the shadow\u0026#8217;s reported state to acknowledge the request.\nFigure 2. Activate Dispenser In this flow:\nRequest - User clicks on \"dispense\" button in web applicationLambda is invoked for that requestDispenser record readIf there is a good balance and no in-process requests \u0026lt; 5 seconds old:Record a new request in the dispenser recordPublish the request object to the dispensers shadow desired stateLog a successful request eventReturn to the API/web app a success messageIf there is not enough credits or a dispense request is still valid (\u0026lt;5 seconds old):Log an errorReturn to the API/web app a descriptive error The response operation is decoupled from the request in that the dispenser may be in an offline state. Once online, the response flow continues:\nDispenser received a shadow update on $aws/things/shadow/123/delta or $aws/things/shadow/123/update/acceptedIf the timestamp of the request is older than 5 seconds:Add a response object to the reported state with a result=ERROR indicator (optional - if submitted no credits will be deducted)Discard the message and log locallyIf the request is current (less than 5 seconds old):Activate the motor for set durationIn parallel if possible, a response object to the reported state with the same requestIdThe response message triggers the Rules Engine which looks at the shadow document for a state.reported.response objects and if found invokes the Lambda functionLambda determines this is a rules invocation and not APIReads the dispenser recordIf there is a matching requestIddeduct $1.00, clear requestId, update dispenser recordLog successful dispenser operationsDelete (set to null) and request and response objects in the dispensers shadowIf no matching dispense requestId was foundLog error (should not arrive here)Delete (set to null) and request and response objects in the dispensers shadow The Lambda will also clear out a stale dispense request. There can only be one in-flight dispense request in the dispenser\u0026#8217;s record.\nNote: A dispenser may get a free pour if it receives the dispense command and then goes offline before publishing the response message.\n Rules Engine FlowsThese flows are subscriptions made by the rules, and the actions they take.\nLogging EventsThe logging rule monitors all messages published to events and events/#, and invokes a Lambda to persist the events into the DynamoDB EventsTable.\nFigure 3. General Event Logging There are three logging rules for the workshop, all which log events to the EventsTable. The LogShadowEvents rule monitors for shadow update documents, adds the topic which will identify the dispenser, then invokes the ProcessEvents Lambda function. Similarly for messages published to the events and events/nnn (dispenser ID) topics, the LogGenericEvents and LogDispenserEvents rules process the messages and invoke ProcessEvents.\nThe Lambda function parses the incoming details and creates the formatted entries that then published to the DynamoDB EventsTable.\n "
},
{
	"uri": "https://cdd.example.com/docs/presenter/prerequisites.html",
	"title": "Prerequisites",
	"tags": [],
	"description": "",
	"content": "We have strived to keep the amount of prerequisites to a minimum in order to setup the infrastructure for the workshop. Please ensure that all of these are completed before progressing to the next step.\n An AWS account to be used to host the workshop services and participant IAM user accounts. It is recommended to use or create a new or sandbox account as the participants will have permissions to see resources. Have a local Workstation or laptop available\nTo build and run the CloudFormation steps, you will need a workstation, an EC2 instance, or a laptop. All the steps are written and based on Linux/macOS. If you don\u0026rsquo;t have a similar environment, you may use an Amazon Linux based EC2 instance. No matter what you use, please ensure the following tools are installed:\n AWS CLI with admin credentials (see below) NodeJS \u0026gt;= 8.11.x and npm Python \u0026gt;= 3.6 and pip AWS Cloud Development Kit (CDK)  The following commands will verify that the command line tools are properly installed: $ aws iam get-account-summary # AWS CLI { \u0026#34;SummaryMap\u0026#34;: { ... } } $ node -v # NodeJS v12.8.0 $ npm -v # Node package manager 6.10.2 $ python --version # Python Python 3.7.4 $ pip --version # Python module manager pip 19.2.2 from ... $ cdk --version # CDK utility (from npm) 1.4.0 (build 175471f) \n An AWS CLI named profile. The profile in ~/.aws/config should contain the target region, and the ~/.aws/credentials file should have an access key and secret access key with administrative access (or minimum to deploy and run the stack). The profile name cdk-user will be used throughout this guide.\n A registered domain name managed by Route 53 in the workshop account. This can either be through registration in Route 53, or making Amazon Route 53 the DNS service for the domain. If we want the URL for the workshop to be cdd.example.com, in Route 53 there needs to be a public hosted zone for example.com.\n To target the appropriate account, region and other aspects, the following entries need to be considered and changed in the config.json file (the default value used in this guide listed first):\n Region - us-west-2Region identifier, must support all AWS resources being used. HostName - cdd.example.comThe fully qualified domain name entry to be created from the Route 53 hosted zone details above (example.com). Note, subdomain entries can also be used such as cdd.foo.example.com, but must be created from Route 53. ProfileName - cdk-user\nThe AWS CLI profile name referenced above. It is used by the build and deploy steps to use the right account and credentials. AdminUserName - adminThe username to log into the web application for administrative purposes. AdminPassword - NO DEFAULT VALUEThis needs to be completed in the config.json file and is only used for web application related tasks, and not for AWS account activities. cloud9InstanceSize - t3.smallInstance size for each participants Cloud 9 environment. Select larger (or smaller) depending upon how long the Amazon FreeRTOS compilation should take. ParticipantLimit - 20The maximum amount of user accounts that can be created, after which, new account creation will fail. It is best to set this to 5-10% above total expected participants.  An Amazon Certificate Manager (ACM) validated server certificate in N. Virginia, to encrypt access to the web application. The certificate needs to be created in the N. Virginia region to work with Amazon CloudFront. Also, the issued certificate must support the fully qualified domain name you wish to use. For example, a certificate for *.example.com is valid for the domain name cdd.example.com, but would not work for cdd.foo.example.com since the wildcard is only matches the third element foo, and not the fourth one, cdd.\n   "
},
{
	"uri": "https://cdd.example.com/docs/participant.html",
	"title": "Workshop Participant",
	"tags": [],
	"description": "",
	"content": " Welcome Workshop Participant! The Connected Drink Dispenser, or CDD, simulates a fleet of physical devices managed and controlled by a cloud-based architecture. The physical device, which you will build, can dispense a drink from a standard bottle such as soda or water through an controlled air-pump, and uses an ESP32 microcontroller (MCU) as the brains of the operation. Connectivity to AWS IoT is done through a Wi-Fi network connection, and interaction and local device control is performed by an Amazon FreeRTOS application running on the MCU.\nReplace with image of controller calling out the components and connection to the cloud.\n To simulate dispenser activities, a web application (webapp) with user authentication is used. It can control dispensing a drink via the dispenser associated with the user, and to provide credits to other dispensers. This demonstrates how devices can be scoped down to limited permissions and actions, while still taking advantage of robust serverless applications.\nReplace with image of controller icon, web app icon, and cloud with interaction.\n Using This Documentation This section of the document covers the exercises you will be working through to completed the workshop. There are few things to note while walking through the modules:\n Modules build on each other - Please ensure that each module is completed in-order, and if there are checkpoints at the end, each is complete and operational. Do not move onto the next lab until this is validated. If you do have any questions, please raise you hand for support.\n Comprehension over completion - Each module will start with a set of objectives, a step-by-step walk through on how to complete. Besides the how, there will be a set of why takeaways which will be helpful in the future when using these skills.\n Lab context - Some modules be more of seeing what happens when certain operations that place. These will be put into context for the overall architecture of the Connected Drink Dispenser workshop.\n  You can navigate either from the menu to the left, or by using the blue navigation arrows (\u0026lt; and \u0026gt;) to move forward or back a page.\nLet\u0026rsquo;s get started by navigating forward to Activities Page!\n"
},
{
	"uri": "https://cdd.example.com/docs/participant/lab_modules/2_laptop_setup.html",
	"title": "2. Laptop Setup",
	"tags": [],
	"description": "",
	"content": " Objectives In this lab you will configure your laptop for the workshop. By the end of the module you will have:\n A directory or folder to hold all the files required for your dispenser. Installed and tested a device driver to communicate with the microcontroller. Downloaded a command line utility to program (flashed) the microcontroller. Have an open terminal or command prompt ready to issue commands.  The microcontroller is programmed, or flashed, via a USB serial connection from a computer or laptop. Based on the microcontroller chipset, a specific driver is required.\nEach persons laptop is unique and the general instructions may not work for a variety of reasons such as having a older version of the driver loaded, insufficient permissions to install, or older versions of Operating Systems. Please ensure that the checkpoint at the end has been completed prior to starting the next lab.\n Steps to Complete Follow each step in order and use the Open for detailed step-by-step instructions if required.\n1. Create Local Folder Create a local folder called cdd that will contain all downloads and assets needed for the workshop. It is recommended to create this within your web browsers default download location. When asked to download resource X to cdd folder, save or move the files to that folder.\n  Open for detailed step-by-step instructions    Open a file browser for your operating system (Windows: Explorer, macOS: Finder) and navigate to the default download folder used by your web browser. Create a folder named cdd within Downloads. Leave the file browser open as we will be using it to move files around in later modules.    2. Download and Install Serial Driver The microcontroller used in this workshop, the ESP32-DevKitC has a built-in Silicon Labs CP210x serial controller. In order for you laptop to communicate, download and install the CP210x USB to UART Bridge VCP Drivers for your operating system. Follow the instructions exactly, you may be required to provide permissions to the driver and in some cases restart you laptop to complete the installation process.\nUse the installer specific to the exact version of your operating system. Using the wrong driver will not work and may make it difficult to install the proper version later.\n   Open for detailed step-by-step instructions    Open a browser window to the the CP210x USB to UART Bridge VCP Drivers download page. Download the software (the Download VCP link) for your operating system. If in doubt, please verify the version and read the release notes to confirm. Once downloaded, follow the instructions to complete the installation of the driver.  Here are some tips for popular operating systems:\n Windows 10 - Unzip and use installer for either 32-bit or 64-bit. The VCP driver may have been installed by Windows Update, but using the SIlicon Labs provided driver will work with the ESP32-DevKitC. WIndows 7/8/8.1 - Use the default driver, not the serial emulation one. The VCP driver may have been installed by Windows Update, but using the SIlicon Labs provided driver will work with the ESP32-DevKitC. If the default driver does not work, you may try the other driver. macOS/OSX - Mount the DMG file, or use the legacy folder for OSX 10.9 or 101.10. NOTE: On MacOS 10.13 and later, the installation of the driver may be blocked. To unblock, open the System Preferences Security \u0026amp; Privacy pane and unblock the system extension. See Apple Technical Note TN2459 \u0026ldquo;User-Approved Kernel Extension Loading\u0026rdquo; for more information.    3. Download and Install esptool To interact with the microcontroller via the serial USB connection, there is a specific application to be used called esptool. A pre-built executable can be downloaded here for macOS and here for Windows. Unzip or untar the file and place the file in the cdd directory.\nFor Linux users, or to have installed as a Python package, Follow the instructions for your operating system to install the application. If installed correctly the command should accessible from any directory.\n  Open for detailed step-by-step instructions   Option 1 - Executable for macOS and Windows\n Save the macOS or Windows compressed esptool file to your browsers Downloads directory. Unzip or untar and move the esptool file (esptool for macOS, esptool.exe for Windows) from the esptool folder to the cdd folder. This will allow you to run esptool without having to add it to your PATH.  Option 2 - Install as Python Module\n Navigate to the esptool.py GitHub repository and scroll down to the installation instructions section. For your operating system, follow the instructions to install the Python modules. It is recommended to install in a virtual environment or in such a way so that is doesn\u0026rsquo;t affect your operating system\u0026rsquo;s Python installation.  Optional Installations\nIf you are unable to install the esptool or run it via the options above, there are optional versions available for different operating systems. Please note that these have not been tested, and there may be differences between the arguments referenced in the lab modules and the actual software.\n macOS - If you have brew installed, you can install esptool via brew install esptool. Ubuntu - Recent versions of Ubuntu have esptool as an installable package: sudo apt-get install -y esptool. Other mainline Linux distributions may also have similar packages for installation. All Operating Systems - esptool-ck has compiled versions, please check the releases section.    4. Open Command Line Interface and Test All Components To interact with the microcontroller, you will be doing so from a terminal window (macOS and Linux) or a command prompt (Windows). Create a terminal window and change to the cdd directory you created. Verify that you can run the esptool command, and then verify when you connect just the ESP32 via the serial cable that a new serial device is created.\nWhen completed, remove the USB cable from the laptop and microcontroller.\n   Open for detailed step-by-step instructions    For macOS or Linux, launch a terminal window, for Windows launch a command prompt.  Windows - Launch a cmd.exe (Command Prompt). macOS -  + Space -\u0026gt; terminal.app Linux - Control + Alt + T  From the terminal window, run esptool and verify proper operation:\n$ esptool.py -h usage: esptool [-h] [--chip {auto,esp8266,esp32}] [--port PORT] [--baud BAUD] ... $ Monitor what serial ports are in use before connecting the ESP32.\n For Windows, check the current COMx ports. Note that as you connect and disconnect the ESP32, the COMx number may change for each connection. For macOS, ls -l /dev/tty.* will show the ports. You should not see a tty.SLAB_USBtoUART entry yet. FOr Linux, ls -l /dev/tty.* and note the port numbers.  Connect the ESP32, then run the same commands and look for a new addition. That will be the port you will use when flashing and monitoring the microcontroller. When added to a MacBook Pro, a valid driver installation and good data+power USB connection would show this:\n$ # Before connecting ESP32 to laptop $ ls /dev/tty.* /dev/tty.Bluetooth-Incoming-Port $ # After connecting as above /dev/tty.Bluetooth-Incoming-Port /dev/tty.SLAB_USBtoUART Remove the USB cable from both the microcontroller and your laptop.\n    5. Download or Configure Serial Monitor Tool For macOS and Linux, you will use the built-in screen utility to connect to and monitor the microcontroller. There is no configuration required.\nFor Windows, you can either use a serial application already installed or download and use PuTTY.\n  Open for detailed step-by-step instructions for Windows Install of PuTTY    Download Putty from here or here. Run the installation wizard and select all options:\n Configure the Serial line and speed using the COMx port from above (e.g., COM3 and 115200).\n Open the Console to see the microcontroller output.\n  Only one application at a time can access a serial port. When working with esptool, you will have to close the PuTTY console before flashing the firmware. If you get an error about port in use or unavailable, this is most like;y why. Close the Putty Console and try again.\n   Checkpoints Please ensure the following checkpoints are validated before moving on to the next module.\n Folder cdd - Verify and note the location of the folder Serial driver installed and tested - When the ESP32 is connected, the driver is working if a new serial port is created (/dev/tty.SLAB_USBtoUART or similar for macOS, a COMx port for Windows). Command line window left open for other lab modules.  Outcomes Installation of device drivers, tool chains, and utilities such as esptool to interact with microcontrollers is complex, so why do we do it? Unlike cloud environments that can be stood up with infrastructure as code (IaaC), firmware development and testing takes place locally.\nBy completing and testing the installation of the tools in advance of work, we know that our environment is working properly. And if we need to fix or have another laptop or desktop to develop from, the steps to complete setup are documented.\n"
},
{
	"uri": "https://cdd.example.com/docs/presenter/deploy.html",
	"title": "Deploy Stack",
	"tags": [],
	"description": "",
	"content": " This section covers the steps to locally build and then deploy the stack to your preferred region. All steps are completed within the deploy/ directory.\nModify Template Files Copy the deploy/config.json.default to deploy/config.json and modify the new file and change the following parameters with the values from the prerequisites section:\n Region - AWS region to deploy and run the stack (for example, us-west-2 from previous section). HostName - Fully qualified domain name for the stack to build and use, must not exist, it will be created. ProfileName - The name of the AWS CLI profile with administrative permissions.  Process Local Dependencies There are various python packages that need to be installed within the deploy/.env directory in order for CDK to run and process the stack. Follow these steps once to install the dependencies.\nChange to the deploy/ directory and activate the Python virtual environment.\n$ cd Connected_drink_dispenser/cdk $ source .env/bin/activate # sh or bash $ pip install -r requirements.txt Verify by running cdk synth which will return a long CloudFormation stack in YAML. As long as no errors were returned, the cdk synth command has verified dependencies and created the artifacts in the cdk.out/ subdirectory (don\u0026rsquo;t delete this directory).\nDeploy Stack via CDK and CloudFormation With the prerequisites and config.json set, run cdk deploy. This will take at least 30 minutes if not longer as there is a CloudFront (CDN) distribution involved. The final output should look like this:\n✅ cdd-workshop Outputs: cdd-workshop.StaticSiteBucket34E5D9AF = cdd.example.com-static-site cdd-workshop.APIEndpoint = https://xxxxxxx.execute-api.us-west-2.amazonaws.com/prod/ cdd-workshop.CognitoIdentityPool = us-west-2:38c0c443-xxx-xxxx-xxxx-692ebe311dfe cdd-workshop.UserPoolCognitoUserPoolIdArn107A6E54 = arn:aws:cognito-idp:us-west-2:123456789012:userpool/us-west-2_foo cdd-workshop.StaticSiteDistributionId8C64EF2A = E1MK8XXXX2S9X cdd-workshop.APIEndpoint1793E782 = https://xxxxxxx.execute-api.us-west-2.amazonaws.com/prod/ cdd-workshop.UserPoolCognitoClientId49B6D8C4 = 4hp8jitmd6virxxxxxo68p6 cdd-workshop.UserPoolCognitoUserPoolIdA08E3514 = us-west-2_foo Stack ARN: arn:aws:cloudformation:us-west-2:123456789012:stack/cdd-workshop/deadbeef-d008-11e9-8962-02dbab669d48 $ When completed, you should be able to navigate to https://cdd.example.com to verify that CloudFront is working. There will be a NoSuchKey error, which we will fix in the next step, but you can verify that the HTTPS certificate is in place.\nIf there are any errors running cdk deploy, the stack will automatically rollback and delete all the resources. Due to the CloudFront distribution, this will take 30 minutes or longer to complete. Review the error, correct, and re-run the deploy step. Most errors will either be related to permissions associated with the credentials used to deploy, or lack of one of the prerequisites.\nDeploy Application and Documentation With the stack deployed, we need to read some of the outputs from above, create the single page application, and then deploy it and this documentation. To do so, run the deploy_app.py script.\n$ python deploy_app.py Verifying local configuration files Reading CloudFormation stack parameters to create files for web application Clearing S3 bucket of ALL objects Copying web application to S3 |################################| xxx/xxx⏎ Copying online documentation to S3 |################################| 121/121⏎"
},
{
	"uri": "https://cdd.example.com/docs/presenter.html",
	"title": "Setting Up the Workshop",
	"tags": [],
	"description": "",
	"content": " Welcome Presenter! This section will walk you through setting up the Connected Drink Dispenser workshop for participants. It covers the workshop setup, how procure and build hardware, and the approach to introduce the workshop and mentor the participants attending hte workshop.\nEach section covers details for understanding, setting up, and presenting the workshop. Follow each of these sections in order to fully build the workshop.\n Prerequisites to host the workshop for one or multiple runs. Building and deploying the workshop cloud assets. Procuring drink dispenser hardware. Presentation tips and FAQ for supporting participant. Layout of the repository.  "
},
{
	"uri": "https://cdd.example.com/docs/participant/lab_modules/3_create_account.html",
	"title": "3. Create Account/Resources",
	"tags": [],
	"description": "",
	"content": "ObjectivesThis lab module will walk though creation of user and account resources, and accessing your unique resources. By the end of the module you will have:\nCreated and verify a user account.Understand what takes places during account creation.Know where to navigate in order to download and access your specific resources such as certificate and private key, and access other user details.Been introduced to UML sequence diagrams used to illustrate operations. Resource Creation ProcessWhen you first go through the user creation process, there are no resources created in advance. Once you log in for the first time, the API call that returns your resources will notice there are none and will go about creating them. At a high level, the process looks like this:\nUser John Doe registers and verifies new account jdoe.User created in Cognito User Pool and valid JSON web token returned.As this is the first login, a call to the /getResources method is called and invokes a Lambda function.The function creates all of the unique resources for John on a per-service basis.The following resources are created and the results return to the Lambda function:An AWS IoT thing (dispenser) and certificate are created, and associatedAn IAM user account is created with generated passwordA Cloud9 development environment is createAll of the created resources are stored in a DynamoDB table that can only be accessed by the Lambda function. Finally, the /getResources returns John\u0026#8217;s specific details to be used or displayed in the webapp. This same sequence of events can also be presented using a sequence diagram. Each actor or participant is a column, and from top to bottom are the activities. See if you can associate the diagram above from this sequence diagram figure:\nFigure 1. Create User Resources Process Sequence diagrams a consistent way to depict the flow of steps, especially for complex or multi-step operations. Depending upon what is being described, either of these may be used in the lab modules. Now that you have an understanding of what is taking place behind the scenes, it\u0026#8217;s time to create your account!\n Steps to CompleteFollow each step in order and use the Open for detailed step-by-step instructions if required to create your account and access the resources.\n1. Register for an AccountOpen URL provided in the presentation, and click on the create a new account link, or from the SIGN IN link, click on the Sign up link at the bottom of the Sign in page. For your account, enter a Username, Password, and Phone number for your mobile phone to receive a validation code. Once you receive the verification code, enter it to complete the account sign up process.\nThe phone number must be in the \"+county code\" format. For instance, a US number would be \"+18005551212\" and for the UK \"+447624\u0026#8230;\u0026#8203;\", etc. If you have questions about the format, or are unable to receive an SMS message, please let one of the lab helpers know and they can complete the process for you.\n   Open for detailed step-by-step instructions   Navigate to the URL provided during the workshop overview. https://cdd.example.com will be used in these instructions, replace with what was provided.From the Welcome to the Connected Drink Dispenser Workshop! section, click on the create a new account link.\nChoose a username (an e-mail address works and will not be used to send any emails), password, and enter your mobile number for SMS verification code.\nThe page will refresh to the Confirm sign up page to enter the Confirmation code. Check your phone for the 6-digit code, enter it, and click CONFIRM. If successful you will directed to the Sign in page.   2. Initial Log InWith the account created and on the Sign in page, log in with your username/password. Initially you will see a Loading Resource page, and during this first log in, it will pause while the resources are created in the background. This can take approximately 30 seconds or so to complete. Once complete, the dispenser details page will load. Click the MY DETAILS button to open the resources section. Click on the CERTIFICATE FILE, PRIVATE KEY FILE, and AMAZON ROOT CA1 FILE links and save the files to your cdd directory on your laptop. Click the MY DETAILS button to toggle closed.\n  Open for detailed step-by-step instructions   From the Sign in page, enter your your username and password and click LOG IN.The Loading Resource page will appear, followed after a few seconds a notice about resource creation. Do not refresh or click other links at this point. Resource creation can take approximately 30 seconds or so to complete.\nOnce the resources have loaded, toggle the MY DETAILS button to open the resources section. Click on the CERTIFICATE FILE, PRIVATE KEY FILE, and AMAZON ROOT CA1 FILE links and save the files to your cdd directory on your laptop. Click the MY DETAILS button to toggle closed.\nYour browser does not support the video tag. After downloading the files, note that your username appears in the upper right corner indicating you are logged in, and your unique dispenser number and credits are noted in the upper left.   CheckpointsPlease ensure the following checkpoints are validated before moving on to the next module.\nYou have successfully created a user account and saved the user username and password for future use.You have downloaded the certificate file (e.g., 34ea05fe7b-certificate.pem.crt), private key (e.g., 34ea05fe7b-private.pem.key) and root certificate CA (AmazonRootCA1.pem). This validates that all resources have been created in the cloud based on your username and assigned dispenser Id. OutcomesWe provided a detailed explanation of what happens during account and resource creation to show a process for just in time registration of resources. In our case, it was the creation of the user account and resources, but a similar pattern can also be used to generate AWS IoT things, certificates, and policies just as a new device needs them, and not in advance.\nIf you are interested in how the resource creation process takes place, look at the code for the ApiGetResourcesFunction Lambda function when you are logged into the AWS Console.\n "
},
{
	"uri": "https://cdd.example.com/docs/participant/lab_modules/4_esp_setup.html",
	"title": "4. MCU Setup &amp; Test",
	"tags": [],
	"description": "",
	"content": " Objectives This lab module will walk you through connecting the components to test the operation of the dispenser without having to build the entire dispenser at this time.\nBy the end of this module you will have:\n Installed all the components needed to test the operation of the dispenser firmware with the cloud backend. Have an understanding of what each component does. Be able to communicate with the microcontroller via your laptop.  Building the dispenser takes up a lot of room. For now, just remove the parts mentioned below and leave the rest in the zip-top bag. Promise: You will build entire dispenser in a bit!\n The Ring LED is controlled by the microprocessor, and is used to denote the status of the overall application. It is powered and controlled by microcontroller and the firmware you will compile and flash.\nThe Controller Board serves a few functions.\n It acts as carrier for microcontroller, and provides easy to use connectors for the other components being connected such as the Ring LED, external power, and the aquarium motor which will be installed later. It allows for either USB provided power to test (however there is not enough power to active the motor), or can be powered by an external battery, such as the 9V provided. It also helps anchor all the components into the final design build while still providing access.  Steps to Complete Follow each step in order and use the Open for detailed step-by-step instructions if required.\n1. Remove the Components to Use Remove these four components from the zip-top bag:\n ESP32 Microcontroller Controller Board Ring LED USB Cable (Type-A to Micro USB data and power)  TODO: image of four components\n2. Connect the LED Ring to the Controller Board Install the LED Ring into the WS2812 3-pin connector on the Controller Board with the tab aligned with the connector slot.\nTODO: image of LED connected to controller board.\n  Open for detailed step-by-step instructions    Hold the Ring LED cable\u0026rsquo;s connector between your fingers. Align the tab on the connector with the slot on the 3-pin WS2812 labeled receptacle on the Controller Board. With slight pressure, insert the connector until it is fully in.    3. Install the Microcontroller into the Controller Board Align the microcontroller into the dual inline socket on the other side of the Controller Board, aligning the large metal square package with the Motor A Motor B text on the controller board. Make sure all pins on the ESP32 and the socket, then gently insert until all the way in.\nTODO: pic of iso view of insertion\nIt is very easy to accidentally bend the pins on the microcontroller. Turn over the Controller Board with the socket facing up, and then with your other hand gently position the microcontroller pins into the holes. Once all are in place, gently apply pressure equally (center of microcontroller works best) to insert all the way in. If you accidentally install backwards, place a finger underneath one end of the microcontroller and apply pressure to lift slightly. The do the same on the other end and alternate back and forth until the microcontroller is out of the socket.\n   Open for detailed step-by-step instructions    Hold the Controller Board in one hand with the socket side (opposite of the LED Ring connection) facing up. In your other hand hold the microcontroller and align the side with the large metal side with tab (antenna) to the Controller Board with Motor A Motor B text. Align the pins on the microcontroller to the socket and lightly place. Ensure each pin is in a hole.  TODO: side image not flush\n With gentle, even pressure, press the microcontroller in the socket until flush.  TODO: side image fully flush\n  4. Connect the Microcontroller to Your Laptop and Test Serial Communication Insert the USB cable\u0026rsquo;s Micro USB connector into the end of the microcontroller, and the Type-A connector into your laptop. The red LED on the microcontroller indicates power, and the Ring LED may light up. Next, check that the serial port tested in the Laptop Setup module is there. Next, use the serial monitoring software to connect to the serial port. Press the button to the left of the USB connection and verify you see text after each press. Exit your monitoring software.\nTODO: image of lit unit\nA Micro USB to Type-A cable was provided. If your laptop only has Type-C connector and you have a Micro USB to Type-C cable, make sure that it supports both power and data connections. The workshop presenter may have Micro USB to Type-C cables to loan out.\n   Open for detailed step-by-step instructions    Insert the USB cable into the microcontroller, and then your laptop and verify that is had power via the red LED on the microcontroller. Use the serial monitoring tool to verify that the same serial port for your laptop still works. In some cases, especially in Windows, this value may change on each connection or if you use a different serial port. Press the button to the left of the USB connection and verify you see text after each press. It should look similar to this:\nrst:0x1 (POWERON_RESET),boot:0x13 (SPI_FAST_FLASH_BOOT) configsip: 0, SPIWP:0xee clk_drv:0x00,q_drv:0x00,d_drv:0x00,cs0_drv:0x00,hd_drv:0x00,wp_drv:0x00 mode:DIO, clock div:2 load:0x3fff0018,len:4 load:0x3fff001c,len:6340 load:0x40078000,len:11276 load:0x40080000,len:6084 entry 0x4008032c I (28) boot: ESP-IDF v3.1.3-13-g44a799c47 2nd stage bootloader I (28) boot: compile time 18:50:42 I (28) boot: Enabling RNG early entropy source... I (34) boot: SPI Speed : 40MHz I (38) boot: SPI Mode : DIO I (42) boot: SPI Flash Size : 4MB I (46) boot: Partition Table:  Exit the monitoring program. You may leave the microcontroller attached if you like.\n    Checkpoints Please ensure the following checkpoints are validated before moving on to the next module.\n The Ring LED and microcontroller are connected to the Controller Board. The microcontroller has power when connected to your laptop. You can see text via the serial monitoring tool.  Outcomes So why are we only installing a few pieces of the entire dispenser instead of building now? When doing embedded software development, it is easier to work with a development microcontroller kit and the accessories you will be controlling. Normally this would be done with a breadboard or some other development kit (devkit). However, for those that are not familiar with that process, using the minimum pieces now will allow us to continue testing up until we do incorporate the components into the overall dispenser.\n"
},
{
	"uri": "https://cdd.example.com/docs/participant/lab_modules/5_cloud9_setup.html",
	"title": "5. Cloud9 Development Environment",
	"tags": [],
	"description": "",
	"content": " Objectives This lab module will walk you through how to launch the Cloud9 IDE and download the device firmware source code to modify and flash onto your drink dispenser. By the end of the module you will have:\n Installed the toolchain needed to compile and link the source code for the dispenser. Cloned the workshop repository which include the dispenser firmware source code. Installed the supporting tools needed to compile.  The AWS Cloud9 Integrated Development Environment (IDE) is a service that runs on EC2 and provides a interactive and consistent development environment. You interact with it via a web browser, and it allows for command line access, a folder tree, and the ability to upload and download files between it and your local laptop.\nUsing Cloud9 is good because it gives a consistent compilation experience no matter the model or age of your laptop. It compiles within a couple minutes (older laptops can take 15 minutes or longer), and if compile times become too long, you can change the underlying instance size to obtain even more CPU or memory resources.\nSteps to Complete Follow each step in order and use the Open for detailed step-by-step instructions if required.\nOpen New Browser Tab to Cloud9 Service and Launch IDE From the webapp, open the MY DETAILS section and open a new browser tab or window to the Sign-in URL, then login in with the credentials provided. From the AWS Console, open a new tab to the Cloud9 service. From the Your Environments menu, click on the Open IDE button for your user. This will open a new tab with the IDE and start up the EC2 instance (it may take a minute to fully launch).\n  Open for detailed step-by-step instructions    For the webapp, open the MY DETAILS section and click on the Sign-In URL to open a new browser tab. Use the username and password credentials from the web app to log into the AWS Console. From the console, click on Services from the top left menu bar, then in the Find a service by name or feature type Cloud9 and right- click on the drop-down service name and select Open Link in New Tab (or something similar). On the Cloud9 tab, click on the Your Environments menu, click on the Open IDE button for your user. This will open a new tab with the IDE and start up the EC2 instance (it may take a minute to fully launch).\n    Install Dependencies Needed For Compilation With the IDE open, close the Welcome tab, and the click the green circled plus icon and select New terminal which will open a command line in the ~/environment directory. From here, copy and paste these lines to the next terminal window to install the dependencies and the Xtensa toolchain for the microcontroller (ESP32). The final commands will add to your PATH so the build process can execute correctly.\n# Install OS utilities needed by toolchain sudo yum -y install flex gperf # Install Python modules (also used by toolchain) sudo pip install argparse cryptography serial pyserial cmake # Install the 64-bit version of the Xtensa ESP32 toolchain cd ~/environment wget https://dl.espressif.com/dl/xtensa-esp32-elf-linux64-1.22.0-80-g6c4433a-5.2.0.tar.gz mkdir ~/environment/esp cd ~/environment/esp tar xvfz ../xtensa-esp32-elf-linux64-1.22.0-80-g6c4433a-5.2.0.tar.gz cd ~/environment # Finally, add the toolchain path to your profile echo \u0026#39;PATH=$PATH:$HOME/environment/esp/xtensa-esp32-elf/bin\u0026#39; \u0026gt;\u0026gt; ~/.bash_profile source ~/.bash_profile # ============= Finished installation of dependencies ============= Clone Workshop Repository The device firmware resides in the workshop\u0026rsquo;s GitHub repository. Copy and paste the following lines to clone the repository locally and change to the directory where the compile operations will take place.\ncd ~/environment git clone --depth 1 https://github.com/aws-samples/connected-drink-dispenser-workshop.git cd connected-drink-dispenser-workshop/device_firmware # ============= Finished installation of Connected Drink Dispenser repository ============= Verify Default Compilation To verify that all components are in place, run the following commands to create the build environment in the device_firmware directory, then change to the build directory (it will be created in root of the repository, at ~/environment/connected-drink-dispenser-workshop/build). Run each of these commands and verify they completed without errors (warnings are okay).\ncd connected-drink-dispenser-workshop/device_firmware cmake -DVENDOR=espressif -DBOARD=esp32_devkitc -DCOMPILER=xtensa-esp32 -S . -B ./build This should only take a few seconds and end with no errors. Then run the make process:\ncd build make all -j4 cd .. Again verify there were no errors. The final output of the build step should look like this:\n... [100%] Building C object CMakeFiles/aws_demos.dir/demos/wifi_provisioning/aws_wifi_connect_task.c.obj [100%] Linking CXX executable aws_demos [100%] Built target aws_demos Scanning dependencies of target app [100%] Generating ../aws_demos.bin esptool.py v2.6 [100%] Built target app And there should be a lot of files in ~/environment/connected-drink-dispenser-workshop/build which is the firmware output from the build process.\nCheckpoints Please ensure the following checkpoints are validated before moving on to the next module.\n In the Cloud9 IDE:  There is a file named aws_demos.bin in ~/environment/connected-drink-dispenser-workshop/build. There were no errors (warning are okay) in either the cmake or make all steps.   Outcomes We used a reproducible method (all the commands above can be automated) to create a development environment and toolchain build process. By doing this, you can always recreate the environment if something gets corrupted. Having the ability to quickly iterate in changes is an important factor in developing firmware.\n"
},
{
	"uri": "https://cdd.example.com/docs/presenter/repository.html",
	"title": "Repository Layout",
	"tags": [],
	"description": "",
	"content": " Repository Layout An understanding of the repository is not required to run the workshop, but can be helpful when deploying the cloud assets or to understand supporting resources. The Connected Drink Dispenser Repository directory structure looks similar to this:\n├── deploy \u0026lt;--- Build and deploy the CloudFormation stack ├── dispenser_app \u0026lt;--- Single Page App (SPA) ├── docs \u0026lt;--- Participant and presenter docs ... └── README.md \u0026lt;--- Main GitHub documentation page The main directories of interest are:\n deploy - Creates and optionally deploys all assets to the cloud for the workshop. dispenser_app - The SPA for managing per-workshop resources (admin user) and the web app for participants to interact with the device. docs - The source files to create the documentation site for inclusion into the main web site along side the dispenser app. You are current here!  "
},
{
	"uri": "https://cdd.example.com/docs/participant/lab_modules/6_flash_and_test.html",
	"title": "6. Flash &amp; Test MCU",
	"tags": [],
	"description": "",
	"content": " Objectives In this lab module, you will complete the configuration of the dispenser firmware, download the compiled files to your laptop, and then use the tools to flash the microcontroller. At that point, the main components of the dispenser with the exception of the motor, will be fully operational. By the end of the module you will have:\n Modified the base firmware code to work with your specific account. Compiled and downloaded the code files to your laptop. Flashed the microcontroller with the compiled code on your laptop. Verified it is communicating with AWS IoT by turning on and off the LED.  Steps to Complete Follow each step in order and use the Open for detailed step-by-step instructions if required.\nModify the Source Files for Your Dispenser The X.509 client certificate and private key you downloaded earlier to your laptop\u0026rsquo;s cdd directory uniquely identify your dispenser from all others. In order to communicate to AWS IoT core, you need to modify two of the source files in Cloud9 with the following in device_firmware/demos/include:\n   Firmware Source File #define Statement in File Content     aws_clientcredential.h clientcredentialMQTT_BROKER_ENDPOINT AWS IoT Endpoint value from MY DETAILS section of webapp   aws_clientcredential.h clientcredentialIOT_THING_NAME Your assigned dispenser name (3-digit number) to use when connecting to the MQTT broker   aws_clientcredential.h clientcredentialWIFI_SSID WiFi network name provided by workshop presenter   aws_clientcredential.h clientcredentialWIFI_PASSWORD Provided password for the WiFi network   aws_clientcredential_keys.h keyCLIENT_CERTIFICATE_PEM Converted X.509 certificate (nnn-certificate.pem.crt) content from Credential Formatter   aws_clientcredential_keys.h keyCLIENT_PRIVATE_KEY_PEM Converted certificate private key nnn-private.pem.key content from Credential Formatter    In Cloud9, navigate to the device_firmware/demos/include folder, then double-click on the two files above and modify the contents. The output for the last two PEM files in aws_clientcredential_keys.h, when copied over should look similar to this before and after (certifcate only, do the same with private key):\nBEFORE:\n#define keyCLIENT_CERTIFICATE_PEM \u0026quot;REPLACE_WITH_CONVERTED_CERTIFICATE_STRING\u0026quot;  AFTER:\n#define keyCLIENT_CERTIFICATE_PEM \u0026quot;-----BEGIN CERTIFICATE-----\\n\u0026quot;\\ \u0026quot;MIICxjCCAa6gAwIBAgIVAJhkG3c6wT05SEZKJ3OsVHrQov6nMA0GCSqGSIb3DQEB\\n\u0026quot;\\ ... \u0026quot;IdbvOv7LLT9BD2Z8Mx9H/BhCd9ylpZEyQcl948GjEXgBDGdxUKFhrEfx\\n\u0026quot;\\ \u0026quot;-----END CERTIFICATE-----\u0026quot;  Once both files are modified, save them in the Cloud9 IDE, but leave them open to make changes if needed later.\n  Open for detailed step-by-step instructions    In Cloud9, navigate to the device_firmware/demos/include folder then double-click the two source files to modify:\n In each file reference above, replace the contents between the double-quotes. All values you need to replace start with \u0026quot;REPLACE_WITH_...\u0026quot;. Here are examples of what the WiFi and Certificate values should look like when done:\nBEFORE: AFTER:   The WiFi SSID must be entered exactly as given. Also, for the certificate and private key entries make sure the ---BEGIN and ---END look exactly as above. The data will be different and the private key will only be a few lines long as it is an ECC key.\n  For each file, click the tab the from the Cloud9 menu, save both files (File-\u0026gt;Save). Leave both files open as it will be easier to correct and potential errors.    Compile and Download the Code from Cloud9 With the updated files save, click on the terminal window where you did the compile steps in the previous lab. Run the make command again which will pick up the file changes and compile the firmware.\ncd ~/environment/connected-drink-dispenser-workshop/device_firmware/build make all -j4 Navigate in the Cloud9 file browser and open the connected-drink-dispenser-workshop/device_firmware/build folder. Scroll down and right-click on aws_demos.bin and select Download and save to your cdd directory. Do the same for the build/bootloader/bootloader.bin and build/partition_table/partition_table.bin files.\nIn your laptop\u0026rsquo;s cdd directory you should have these three files.\n  Open for detailed step-by-step instructions    In Cloud9, click on the terminal window and rebuild the device firmware.\ncd ~/environment/connected-drink-dispenser-workshop/device_firmware/build make all -j4  Right-click on aws_demos.bin, select Download, and save the file to your cdd directory. Do the same in the bootloader folder for bootloader.bin, and in partition_table for partition-table.bin.\n When completed, make sure that aws_demos.bin, bootloader.bin, and partition_table are saved and available in your laptop\u0026rsquo;s cdd directory.\n    Flash and Monitor the Microcontroller from Your Laptop Short description of what to do for experienced people\n  Open for detailed step-by-step instructions   detailed steps with markdown.\n  Checkpoints Please ensure the following checkpoints are validated before moving on to the next module.\n(optional) Outcomes Lead off with something like \u0026ldquo;so why did we do x, y, and z?\n"
},
{
	"uri": "https://cdd.example.com/docs/participant/lab_modules/7_investigate_cloud.html",
	"title": "7. Review Cloud Architecture",
	"tags": [],
	"description": "",
	"content": "ObjectivesThis lab module will walk through how the dispenser, webapp, and coupled services interact. It will go into level of detail specific for the workshop. If you would like to review more details, please reference the Setting Up the Workshop documentation for deeper insights. By then end of this module you will have:\nAn understanding of the relationship between the dispenser (thing), your Cognito user, and the DynamoDB database tables that track and log dispenser activity and state.Seen how the dispenser thing uses the Device Shadow Service for AWS IoT to listen for requested state changes, and also uses it for processing a dispense request and acknowledging a dispense response.Tested a dispense request/response operation and monitored what takes place in different scenarios.Reviewed dispenser activity from both the DynamoDB EventsTable and also webapp logging.An understanding of how the webapp along with the API Lambda functions control how to give credits to others, as well as only initiating a dispense event when there sufficient credits. Steps to CompleteFollow each step in order and use the Open for detailed step-by-step instructions if required.\nUnderstand the AWS IoT Thing, Cognito User, and DynamoDB Table RelationshipsAs a software-as-a-service (SaaS) environment, there needs to be a specific relationship between all of the resources to help enforce the security and operational controls of the actions. At a high level, for each user, this is how the resources are associated with each other:\nFigure 1. Relationship between services Each thing has a unique X.509 client certificate for authentication allowing the dispenser to connect publish and subscribe to the MQTT topics specific for that dispenser. This authorization of MQTT topics comes from a common policy that uses substitution variables that read the Common Name value (which is the dispenser Id). The relationship continues into a Cognito User attribute, custom:dispenserId, that is read for every API call. Finally, your dispenser has an entry in the DynamoDB DispenserTable that tracks current the credit balance and also any in-flight or stale command operations.\nFrom the browser tab opened to the AWS Console review the relationships by viewing your dispenser and user details in the following AWS services:\nAWS IoT Core - View your thing, the attached certificate details, and the policy associated with the certificate. Also, view the other security policy that is associated with your Cognito user (used to monitor update events).Amazon Cognito - From Manage User Pools, select the workshop-users, Users and Groups, then your select your username. Note the custom:user and custom:dispenserId attribute values.Amazon DynamoDB - From the DispenserTable review the credits value for your dispenser via the dispenserId sort key. From the DispenserEvents table, query with the partition key equal to your dispenserId. As others start to create and operate their dispensers, filtering will limit to just your events.   Open for detailed step-by-step instructions   From the browser tab opened to the AWS Console, click on the Services menu dropdown (upper left next to AWS logo), and type in iot core, then click on IoT Core when the drop-down populates. This will direct you the the AWS IoT Core service page.\nTip: During the workshop you will be changing from service to service quite often. When navigating to a different service via the Service\u0026#8594;SERVICENAME, right-click on the service name and select \"Open in a new tab\" (or equivalent). This will have all the services referenced within a single browser window on separate tabs.\nClick on Get Started to take you to the main page, then select Manage from the left tab. Click on Skip tour. This will take you to the list of things. Either select your thing (same as dispenserId), or click on Search things, which is helpful for large amounts of items.From your things page, click on Security. This shows that you have a single X.509 certificate (long hash value) associated with your thing. Click on the certificate which will show details on it. Note that the Subject contains values that are parsed when the certificate is presented, and the value for CN (Common Name) is value of the dispenserId. This is how we relate different resources together.To continue viewing the IoT relationship, from the Certificate page, click on Policies. This shows what IoT policies are associated with the certificate, and by relationship, to the thing. Click on the policy to view its content, which is a JSON document.\nNotice that all of the resources use the substitution variable ${iot:Certificate.Subject.CommonName} as part of the string. What this does is on a per-certificate connection, evaluates the CommonName, or CN, of the certificate and replaces it. This allows for a single policy to used by all the dispensers.\nAbbreviated DispenserLimitedAccess Policy { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Condition\": { \"Bool\": { \"iot:Connection.Thing.IsAttached\": [ \"true\" ] } }, \"Action\": [ \"iot:Connect\" ], \"Resource\": [ \"arn:aws:iot:REGION:ACCOUNT:client/${iot:Connection.Thing.ThingName}\" ], \"Effect\": \"Allow\" }, { \"Action\": [ \"iot:Subscribe\" ], \"Resource\": [ \"arn:aws:iot:REGION:ACCOUNT:topicfilter/$aws/things/${iot:Certificate.Subject.CommonName}/shadow/*\", \"arn:aws:iot:REGION:ACCOUNT:topicfilter/$aws/things/${iot:Certificate.Subject.CommonName}/cmd/${iot:Certificate.Subject.CommonName}\" ], \"Effect\": \"Allow\" } ] }Next, from the Services menu, select Cognito, click Manage User Pools, and then click on the workshop-users pool. This is the service that manages the user account you created from the webapp. Under General Settings select Users and groups to display all of the user account. Search for your username and click on it. At the bottom you will notice a couple custom: attributes. The first, custom:group user denotes that your account is a general user account (extra credit, check out the admin user). The second attribute, custom:dispenserId shows your dispenserId value. These fields are passed whenever you make an API call from the webapp and used by the Lambda functions to validate what actions you are allowed to take.From the Services menu navigate to DynamoDB, which contains the database tables. Select Tables from the left menu, select the DispenserTable name, then select Items from the right pane. This table holds a single record for each dispenser. This most important field is credits, and should correspond to the value in the webapp (\"1\" in the table is $1.00 in the webapp). This record is modified every time someone gives you credits, or whenever you issue a dispense operation.Finally, changes tables by selecting DispenserEvents from the left pane. You will see all the various log entries for all dispensers. To view just your dispensers events, click on the Scan dropdown and change to Query, the for Partition key enter your dispenser\u0026#8217;s value and click on Start Search.   Monitor Shadow Changes for a Simple Operation (change LED Status)The Device Shadow Service for AWS IoT is an always available service that can be used by things and applications to set and track the state of device. There are two main sections to the shadow document, the desired state and the reported state. In this workshop, our desired settings will originate from the webapp and the dispenser will act upon them and set the correct reported state.\nFigure 2. Shadow state changes To see this in action, from the AWS Console navigate to your thing in IoT Core, then select Shadow which will show the current shadow. Note the led attribute in the desired and reported sections, which should be the same. Also notice the value for version in the metadata. This increments each time the shadow is updated. To show the shadow is working, use the webapp to change the state of the LED by either toggling or setting to the other state. You will see the value for led has changed in the shadow document, and version has incremented.\nTo see how the shadow works when the device is in a disconnected state, unplug the microcontroller from your laptop. Now, in the webapp change the state of the LED and notice that the desired and delta states show this new value,but that the reported state is still what the dispenser was in before being disconnected. Plug the microcontroller back into your laptop. Once it has booted and connected AWS IoT, the LED will change to the desired state value and the dispenser will update the reported state. Since desired and reported states are the same, the delta state for the LED is removed.\n  Open for detailed step-by-step instructions   Note: In this expanded details section, we will only use a small subset of the entire shadow document and hierarchy to show the desired, reported, and delta sections.\n Navigate to IoT Core\u0026#8594;Manage\u0026#8594;Things\u0026#8594;Your Thing\u0026#8594;Shadow and review the shadow document. Note that the desired and reported sections are the same. This indicates that the device and requested state from the webapp are in sync. At the bottom of the shadow document review the value for version in the metadata. This increments each time the shadow is updated.\n\"desired\": { \"led\": \"off\", \"led_ring\": { \"count\": 5, \"color\": \"FF8000\" } }, \"reported\": { \"led\": \"off\", \"led_ring\": { \"count\": 5, \"color\": \"FF8000\" } }, ... \"version\": 100From the webapp, toggle or change the state of the LED (in this example from off to on). The webapp sets the desired state of the shadow, the dispenser reads this value, turns on the LED, and modifies the reported state to on. You may miss the update in the AWS Console, but check the metatdata and notice that the value for version has increased by at least 2 (once for the webapp setting the desired state and once when the dispenser updated the reported state).\n\"desired\": { \"led\": \"on\", \"led_ring\": { \"count\": 5, \"color\": \"FF8000\" } }, \"reported\": { \"led\": \"on\", \"led_ring\": { \"count\": 5, \"color\": \"FF8000\" } }, ... \"version\": 102To see how the shadow works when the device is in a disconnected state, unplug the microcontroller from your laptop, then toggle or set the LED to the alternate state (in this case from on to off). Notice that the desired and reported states are different, and that there is a delta state which show only those differences. This is useful when you only want to focus on the changes between desired and reported states.\n\"desired\": { \"led\": \"off\", \"led_ring\": { \"count\": 5, \"color\": \"FF8000\" } }, \"delta\": { \"led\": \"off\", }, \"reported\": { \"led\": \"on\", \"led_ring\": { \"count\": 5, \"color\": \"FF8000\" } }, ... \"version\": 103To verify that the dispenser reads the shadow state upon restart, plug the dispenser back into your laptop and watch the shadow document. The dispenser will reconcile the states which will remove the attribute from the delta section (or completely remove it).\n\"desired\": { \"led\": \"off\", \"led_ring\": { \"count\": 5, \"color\": \"FF8000\" } }, \"reported\": { \"led\": \"off\", \"led_ring\": { \"count\": 5, \"color\": \"FF8000\" } }, ... \"version\": 105   Monitor Shadow MQTT topics for a Complex Operation (Dispense Drink)The shadow can also be used for more complex operations. While changing the state of the LED can tracked via a single attribute, operations such as dispensing a drink are more complex and considered a request/response pattern. The webapp initiates the dispense operation as a request, and when the dispenser completes the operation it, in turn, sends a corresponding response. We use a short, random, requestId value to match the correlate the request and response operations.\nFigure 3. Tracking request/response using shadow As we cannot be sure that the dispenser is online, the webapp initiates the request and sets the desired state of the shadow with a request object containing the command to execute, a unique requestId, and the timestamp of when the user clicked \"Dispense a Drink\" in the webapp.\nTo verify, ensure the microcontroller is connected and LED operations take place. Next, use Test from the IoT Core console and subscribe to the topic $aws/things/dispenserId/shadow/# (replace dispenserId with your value) to track all shadow operations. Next, from another tab or window, click the Dispense! button (should still be green) to initiate a dispense operation. From the MQTT Client tab, you should see a few shadow topic messages. Scroll through and review how the first message sets the request object, and after the dispenser completes turning the pump (indicated by the other LED on the controller board) the reported state is updated with a response object that has the same requestId, and finally that the the request and response objects are both deleted from all shadow sections once the response has been reconciliated.\nIn this situation, we are using the shadow to track the status of a command sent to the dispenser, and the response once it acts upon it.\n  Open for detailed step-by-step instructions   Ensure the microcontroller is connected and response to LED on/off events.Navigate to IoT Core\u0026#8594;Test and in the Subscription topic field, enter $aws/things/dispenserId/shadow/# (replace dispenserId with your value) and click Subscribe to topic.From the webapp, click the Dispense! button (should still be green) to initiate a dispense operation. This should turn the other LED on the controller board on for a short period of time and create a few messages in the MQTT Client.Scroll to the bottom (oldest message) and look for the shadow update with desired state that has the first request object.\n{} initial requestThe next message by time will be the dispenser responding to the event publishing to the reported state a response object with the same requestId, signifying that it has completed that request (either with a success or failed indicator).\n{} request and responseOn the cloud side, the matching request and response objects trigger a Lambda function to log the transaction and clear out both objects from the shadow. This is essence reconciling the request to the response, and readying the dispenser for its next operation.\n{} cleared of both   Review Logging and CreditsWe did something bad! We used up all of our credits testing the dispenser operation above. Each dispense operation costs $1.00, and has been deducted from our dispenser, as shown by the webapp. Navigate to the DynamoDB DispenserTable and verify the credits match the webapp. Also, review the EventsTable for your dispenser (review the first steps in this lab if needed) to see the various logging entries made while testing the LED and drink dispense test.\nWe use these tables as the source of truth for the status of our dispenser. While the dispenser code you compiled and installed could be modified, a dispense operation only is created if there are sufficient credits in your account (e.g., DynamoDB DispenserTable entry). We use the relationship of the dispenserId in your user account via the webapp, associated with the same values in IoT Core and DynamoDB, to track the business logic we want to enforce in the overall SaaS application.\n Webapp OverviewThe webapp is your main interface for seeing the state of the dispenser via LEDs, and how to initiate a dispense action. As the webapp is running inside your local browser, there are two methods that can be used to track what is the current status. We can continuously poll via API to return the status, or use a callback mechanism to alert the webapp when something has changed. In this case, the callback method is used. It reduces the overall load on the SaaS service and demonstrates how we again use AWS IoT Core to facilitate this.\nModern web browsers have the ability to monitor what is running locally. Our webapp has additional debug, or console.log() statements to give an indication when something is happening. It does this b subscribing to the MQTT topics for your specific dispenser. From your browser, enable the Web Console (name varies based on browser), and select the Console tab. Now change the status of the LED. Every time you make a change, you will see an Received MQTT message with change in LED or credit status message. This is alerted when an incoming MQTT message of interest such as a shadow update occurs.\nThese messages then trigger the webapp to make an API call requesting the complete status of the dispenser (LED status, credits, etc.), which in turn updates the main dispenser page. If there are no changes being made, no MQTT messages are generated, and subsequently, no API calls are made to request an update to the webapp.\n  Open for detailed step-by-step instructions   Open the Web Console for your browser:FireFox: Select menu Tool\u0026#8594;Web Developer\u0026#8594;Web ConsoleGoogle Chrome: View\u0026#8594;Developer\u0026#8594;JavaScript ConsoleInternet Explorer 11: Either press the F12 key or from the Setting Wheel\u0026#8594;F12 Developer Tools\u0026#8594;ConsoleMicrosoft Edge: From upper right, select \u0026#8230;\u0026#8203;\u0026#8594;More tools\u0026#8594;Developer tools\u0026#8594;Console tabSafari: Preferences\u0026#8594;Advanced Tab\u0026#8594;Show developer menu in menu bar (close Preferences), Develop\u0026#8594;Show JavaScript ConsoleChange the status of the LED with the dispenser connected. Notice the Received MQTT message with change in LED or credit status lines. These a created when the webapp, which is subscribed to a set of MQTT topics receives a message. This is an indication that something may have changes and triggers the webapp to make an API call to the /status method, which returns the dispenser status parsed from the shadow document and the DynamoDB DispenserTable.If there are no changes being made, no MQTT messages are generated, and subsequently, no API calls are made to request an update to the webapp.   Share the Love!So far we have shown how the you interact with your dispenser via the webapp. Next, let\u0026#8217;s build our credits back up to a sufficient level to complete the rest of the lab. To do this, click on the Share the Love! card underneath the LED status cards and follow the instructions. First, try giving credit to another dispenser number and monitor the Last credit response message (with or without browser logging). Next, try to give yourself credits and note that the gray button to the right does not change to SEND CREDIT!. This is a constraint built into the webapp. However, even if you were to make a direct API call, the backend will also deny the request.\nFinally, talk to you neighbor to either side of you and ask them to start sending you credits. You may alsop see that as the credits increase, the ring LED will also start to fill until you have at least $1.00, and after that the colors will changes as your balance goes above $2.00, $3.00, etc.\nIt is recommended that you have at least $2.00 or $3.00 to perform a couple dispenses with a fully built dispenser unit.\nGood work!\n CheckpointsPlease ensure the following checkpoints are validated before moving on to the next module.\nThe dispenser properly operates and toggles the LED status from the webappA dispense operation enabled the other LED on the controller board (motor control)You have an understanding of how the shadow document and DynamoDB tables are used to track the status of state (LEDs) and perform command and control (request/response) operations. OutcomesWhy do we use the shadow document for command and control, when it could also be done with regular MQTT messages? While either pattern are good practices, combining all of the operations into a single location makes it easier to follow for the workshop. As long as there is a way to track each request, the mechanism used doesn\u0026#8217;t matter.\nOne thing that we didn\u0026#8217;t discuss is the ring LED. In this case, it is used to give a visual indication of the credit levels. From the dispensers perspective, it is another shadow attribute set to manage. But instead of being set by clicking buttons in the webapp, this value is programmatically set by the cloud services whenever there is a change in the credit state of a dispenser. This demonstrates that functionality in not static and can be modified in either device (dispenser) or SaaS application (cloud-side).\n "
},
{
	"uri": "https://cdd.example.com/docs/participant/lab_modules/8_build_dispenser.html",
	"title": "8. Build Dispenser",
	"tags": [],
	"description": "",
	"content": " Objectives Statement of what and why we are doing this. Then more detailed list if needed.\nSteps to Complete Follow each step in order and use the Open for detailed step-by-step instructions if required.\nSpecific action to complete Short description of what to do for experienced people\n  Open for detailed step-by-step instructions   detailed steps with markdown.\n  Checkpoints Please ensure the following checkpoints are validated before moving on to the next module.\n(optional) Outcomes Lead off with something like \u0026ldquo;so why did we do x, y, and z?\n"
},
{
	"uri": "https://cdd.example.com/docs/participant/lab_modules/9_final_test.html",
	"title": "9. Dispense a Drink!",
	"tags": [],
	"description": "",
	"content": " Objectives Okay, this is the moment of truth. You have:\n Setup your laptop to flash the dispenser. From Cloud9 compiled the firmware specific for your dispenser. Flashed and tested the cloud capabilities and built up enough credits to operate. Optionally built the dispenser and are ready to test.  With all that completed, let\u0026rsquo;s dispenser a real liquid drink.\nSteps to Complete Follow each step in order and use the Open for detailed step-by-step instructions if required.\nThe following steps are if you are using your own dispenser. If you elect to use one of the pre-built ones, bring your microcontroller (the ESP32) to one of the pre-built stations. Be careful when removing from the controller board as its easy to bend the pins on the ESP32.\n Power On the Dispenser After completing the build step, ensure there is liquid in the bottle, an empty cup underneath, then connect the 9 Volt battery instead of the USB cable for power. Wait until the dispenser is online by viewing the LED status. Now. from 6 inches or 6 feet away click DISPENSE! to pour yourself a drink!\nIf you wish to record this event for posterity, have someone else video you clicking DISPENSE! and having the dispenser pour the drink. Workshop assistants are glad to be your personal videographer if needed!\n If something does wrong or doesn\u0026rsquo;t work, review the build steps from the previous lab, or ask a workshop assistant for help.\n  Open for detailed step-by-step instructions   . Ensure the dispenser unit is built and ready to go: .. Liquid in the bottle .. Top assembly securely screwed down and the output hose centered .. An empty cup under the output hose . Now connect the 9 Volt battery. This will provide power to the microcontroller and the aquarium motor. . Wait for the dispenser to fully come online by waiting for the LEDs to sync to the same status in the webapp. . Okay, with no physical connection between your laptop and the dispenser, click DISPENSE! to pour yourself a drink! . If the dispenser didn\u0026rsquo;t properly dispense a drink, perform some troubleshooting. .. Did you hear the motor whir or make noise? \u0026hellip; Yes: Check that the cap is securely seated on the bottle, there may be a air gap. \u0026hellip; No: Check the connection from the motor to the control board (disconnect the 9V battery first) .. If the LED ring change to the animated dispense pattern, verify there are enough credits and that the dispenser is online (toggle the LED) .. You can also ask a workshop assistant for help in figuring out the problem.\n  Checkpoints There is only one checkpoint to verify, and that is you successfully dispensed a drink!\nOutcomes Congratulations! You have successfully completed the Connected Drink Dispenser workshop. We hope that you enjoyed the session and came away with a general understanding in how you can incorporate AWS IoT services into an overall multi-user or multi-tenant AWS workload.\n"
},
{
	"uri": "https://cdd.example.com/docs/presenter/design_notes.html",
	"title": "Design Notes",
	"tags": [],
	"description": "",
	"content": "This is a compilation of designs used in the hardware and software.\nHardwareThe dispenser has four addressable components:\nled_ring: NeoPixel-based 5-element RGB LED ring. Can set the number of LEDs to light and the RGB color of all the LEDs.motor: Aquarium pump that can be actuated via the first addressable LED/motor h-bridge connectionled: Second addressable LED/motor h-bridge connection - used for initial testing (blinky)led2: Second addressable LED on the h-bridge board SoftwareAPI Methods\nTable 1. ApiTable MethodQuery parametersresponse bodyNotes/getResourcesNone{\"userName\": username, \"dispenserId\": \"100\", \"assets\": null}All responses will include userName and dispenserId. If there are no assets, that will be null, otherwise will be JSON object with the parameters: DynamoDB TablesTable 2. UserTable AttributePartition/Sort KeyFormatDefaultValueusernamePartitionstringnoneuser name from CognitonextDispenserId-string\"100\"The next dispenserId to vend, only added to the admin userdispenserId-stringnonevalue returned by default user adminassets-JSON objectvariesDefault: null, indicator to generate users resources The table is created empty. When the first user signs in, the Sign-in trigger will check for an admin user. If not present it will create one. The additional attributes for the admin user are:\nnextDispenserId - The number of the next dispenser to associate with a user These are the attributes for other users:\nPartition key: userName (string) - User name selected during Cognito sign-updispenserId (string) - Dispenser Id associated with user, IoT thing, etc.assets (object) - During sign-in, the /getResources method will create and populate Table 3. DispenserTable AttributePartition/Sort KeyFormatDefaultValuedispenserIdPartitionstring-3-digit unique value of dispenser, associated with usercredits-Number1Credits available to dispenser. Increment in 0.25 and deduct by 1.00 for a dispenseleaderBoardStatus-Number1Stage of completion. 1 is starting with user/dispenser created, 2 is next step, etc.leaderBoardTime-Number-Timestamp, without microseconds, when latest leaderBoardStatus stage changed.requests-list[] empty listList of active requests [\"requestId|command|timestamp|target\"] The table is created empty, and entries are created or deleted as individual users are registered. The table can be read by participants, but only updated by the admin user and Lambda functions.\nThis table tracks the status of credits, in-flight requests (requests), and other details regarding each dispenser.\nThe requests attribute contains a DynamoDB list of different in-flight requests. In this workshop, only the following is used (in JSON format):\n[ \u0026quot;1234-5678|dispense|12345678|device\u0026quot;, \u0026quot;4567-8901|anothercommand|87654321|device\u0026quot;, ] Both devices and applications interact with the list and construct a JSON message based on the contents, such as:\n{ \u0026quot;clientId\u0026quot;: \u0026quot;123\u0026quot;, \u0026quot;requestId\u0026quot;: \u0026quot;1234-5678\u0026quot;, \u0026quot;command\u0026quot;: \u0026quot;dispense\u0026quot;, \u0026quot;timestamp\u0026quot;: \u0026quot;12345678\u0026quot;, \u0026quot;target\u0026quot;: \u0026quot;device\u0026quot; } This is the representation of the first entry in the list. As requests are completed, the entity that validates the completion will remove them from the list. clientId maps to the dispenserId.\n User account setup and sign-inCognito sign-up and sign-in calls are made. When signing in, the app calls the GetResources method which checks if the authenticated user has a resources entry in the database. If it does, the values are returns. If not, it immediately returns a message so the app can request the CreateResources method. This method executes the following to create the resources:\nCheck if at limit for workshopUse username to create IAM user and credentialsCreate thing, certificate, attach to policycreate Cloud9 instance for userUpdate DynamoDB with the contents And after creation the values are returned within a 25 second period. The application should set a notice to the user that assets are being created and to wait.\nFigure 1. User Sign-up and Sign-in Flow Testing Lambda FunctionsFrom the cdd/ directory, use the following sam local command on the test events in tests/:\n$ sam local invoke \u0026quot;FunctionName\u0026quot; -e event.json $ # Or to use a specific profile $ sam local invoke --profile my-aws-profile \u0026quot;FunctionName\u0026quot; -e event.json Installing Packages for Lambda FunctionsIn order to properly operate in the Lambda runtime environment, use the following steps to include packages with proper share objects or binary components:\nIn the root of the Lambda function, execute the following, replace python version and package(s) to install: $ docker run -v \u0026quot;$PWD\u0026quot;:/var/task -it lambci/lambda:build-python3.7 /bin/bash -c \u0026quot;pip install cryptography -t .; exit\u0026quot; The /bin/bash -c \"pip install cryptography -t .; exit\" is a single line to install the packages in what is mapped to the local lambda directory. You could also use /bin/bash which will place you into the build container where the individual pip install package_name -t . lines could be processed.\n "
},
{
	"uri": "https://cdd.example.com/docs/glossary.html",
	"title": "Standardized Glossary",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://cdd.example.com/docs/_footer.html",
	"title": "",
	"tags": [],
	"description": "",
	"content": "Copyright © 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n"
},
{
	"uri": "https://cdd.example.com/docs/",
	"title": "",
	"tags": [],
	"description": "",
	"content": " Connected Drink Dispenser Workshop Welcome to the Connected Drink Dispenser Workshop!\nFrom this home page you can use the left side navigation to view the content of the workshop.\n"
},
{
	"uri": "https://cdd.example.com/docs/categories.html",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://cdd.example.com/docs/tags.html",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]