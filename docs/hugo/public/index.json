[
{
	"uri": "https://cdd.example.com/docs/participant/lab_modules/1_overview.html",
	"title": "1. Architecture Overview",
	"tags": [],
	"description": "",
	"content": "Objectives In this initial lab, we will go through the overall architecture of the CDD. At the end of the lab, you will come away with the understanding of:\n The cloud components for interacting with the dispenser How user accounts, things, and database entries are interrelated How the dispenser updates local status ands responds to dispense commands  Steps to Complete 1. Overall Cloud Architecture When interacting with the cloud, the architecture utilizes two main paths, AWS IoT Core for MQTT communication and then a dispenser app with authentication to interact with the device and supporting databases.\n IoT Bi-Directional Communication (upper path) - This section uses MQTT to communicate bi-directionally between the AWS cloud and the device. We also use MQTT to notify the dispenser app user when there have been activities. This eliminates the need for constant polling and only to query via API when there is information to update. API Logic (both paths) - Most operations are completed via API calls. By using user authentication, each call can be verified to the specific dispenser via the AWS Lambda functionality. Dispenser App and Authentication/Authorization (lower path) - This uses Amazon Cognito to authenticate users and provide a Jason Web Token (JWT) with signed attributes such as the corresponding drink dispenser id. The vended credentials are then use to make API calls and to establish a persistent connection to AWS IoT.  2. User and Dispenser Relationships For each individual user, there is a set of resources created and related during the user account creation process. A user, foo, authenticates with Cognito and is returned a signed JSON Web Token (JWT) that contains information used by the dispenser app and API Gateway. For instance, user foo is associated with dispenserId of 123. Any API calls made use the dispenserId attribute to ensure that requests are only for the user\u0026rsquo;s dispenser and not someone elses. The value is also used to send and receive messages on specific MQTT topics so that one dispenser cannot be affected by another dispenser\u0026rsquo;s actions. This is a common field used throughout the backend cloud services.\n3. Dispenser Operations Your dispenser will only use MQTT to communicate with the cloud services. There are two main methods that a device uses to communicate. The first is through regular topics such as telem/123 where the device can subscribe to receive messages, or it can publish messages directly to the topic. In this case, telem indicates telemetry and normally would be messages sent from the device to the cloud.\nFor this workshop. instead of command topics you will actually use the shadow set of topics. This is a provided service of AWS IoT that tracks the state of a device. Each device has both a desired and reported state. It is common that cloud services would set the desired state, and the next time the device is online, it would read those values, set them locally, and update the reported state accordingly.\nA device can also use the delta state that tracks the difference between desired and reported states.\nThe shadow document will look similar to this:\n{ \u0026#34;desired\u0026#34;: { \u0026#34;led_ring\u0026#34;: { \u0026#34;count\u0026#34;: 0, \u0026#34;color\u0026#34;: \u0026#34;#FF00FF\u0026#34; }, \u0026#34;led\u0026#34;: \u0026#34;on\u0026#34;, \u0026#34;dispense_time_ms\u0026#34;: 4000, }, \u0026#34;reported\u0026#34;: { \u0026#34;led_ring\u0026#34;: { \u0026#34;count\u0026#34;: 0, \u0026#34;color\u0026#34;: \u0026#34;#FF00FF\u0026#34; }, \u0026#34;led\u0026#34;: \u0026#34;off\u0026#34;, \u0026#34;dispense_time_ms\u0026#34;: 2500, }, \u0026#34;delta\u0026#34;: { \u0026#34;led\u0026#34;: \u0026#34;on\u0026#34;, \u0026#34;dispense_time_ms\u0026#34;: 4000 } } In this example, there are two values that have been requested to be changed, led and dispense_time_ms, as reported by the delta state.\nFinally, there are AWS IoT Rules that are triggered upon the content of messages published. In the diagram above, the IoT rule LogEvent is triggered when the shadow document changes, passing the details to an AWS Lambda function that will write the parsed message content to the Events database table.\nCheckpoints This module provides a high-level description of the various components used in the workshop. After completing this lab, you should have an understanding of:\n The differences between the physical dispenser and the dispenser app used to monitor and control it How Cognito and API Gateway are used by the dispenser app to issue commands or actions How the Dispenser uses MQTT for bi-directional command and control of the device using the Shadow service The differences between the Shadow document states (desired, reported, and delta)  As this lab is informational only, there are no specific checkpoints that need to be completed.\n"
},
{
	"uri": "https://cdd.example.com/docs/participant/lab_modules.html",
	"title": "Lab Modules",
	"tags": [],
	"description": "",
	"content": "Individual Module Overview There are various modules to complete in this workshop. Each module has a specific set of objectives to complete, with the overall goal of the workshop being for you to build, program, and be able to dispense a drink. Each module is laid out in a similar manner:\n ObjectiveA short explanation of what you will be accomplishing, and why. StepsBoth high-level steps to complete the module, and a twirl-down with specific step-by-step instructions CheckpointA completed list of what comes from the objectives that needs to be validated before moving on to the next steps. Outcomes (optional)Depending upon the module, this section describes how the steps taken above help for the workshop or general AWS IoT development patterns.  Workshop Module List These are the labs to complete in order:\n 1. Architecture Overview  Objectives In this initial lab, we will go through the overall architecture of the CDD. At the end of the lab, you will come away with the understanding of: The cloud components for interacting with the dispenser How user accounts, things, and database entries are interrelated How the dispenser updates local status ands responds to dispense commands Steps to Complete 1. Overall Cloud Architecture When interacting with the cloud, the architecture utilizes two main paths, AWS IoT Core for MQTT communication and then a dispenser app with authentication to interact with the device and supporting databases.\n 2. Laptop Setup  Objectives In this lab you will configure your laptop for the workshop. By the end of the module you will: Have a local directory or folder to hold all the files required for your dispenser Have installed and tested a device driver to communicate with the microcontroller Downloaded a command line utility to program (flashed) the microcontroller Have an open terminal or command prompt ready to issue commands, and verified that the microcontroller appears as a serial device The microcontroller is programmed, or flashed, via a USB serial connection from a computer or laptop.\n 3. Create Account/Resources  ObjectivesThis lab module will walk though creation of user and account resources, and how to access your unique resources. By the end of the module you will have: Created and verified a user accountUnderstood what takes place during account creationKnow where to navigate in order to download and access your specific resources such as certificate and private key, and access other user details.Been introduced to UML sequence diagrams used to illustrate operations.\n 4. MCU Setup \u0026amp; Test  Objectives This lab module will walk you through connecting the components to test the operation of the dispenser without having to build the entire dispenser at this time. By the end of this module you will: Have installed all the components needed to test the operation of the dispenser firmware with the cloud backend Have an understanding of what each component does Be able to communicate with the microcontroller via your laptop Building the dispenser takes up a lot of room.\n 5. Cloud9 Dev Environment  Objectives This lab module will walk you through how to launch the Cloud9 IDE and download the device firmware source code. By the end of the module you will have: Installed the toolchain needed to compile and link the source code for the dispenser. Cloned the workshop repository which includes the dispenser firmware source code. Installed the supporting tools needed to compile. The AWS Cloud9 Integrated Development Environment (IDE) is a service that runs on EC2 and provides a interactive and consistent development environment.\n 6. Develop, Flash, \u0026amp; Test MCU  Objectives In this lab module, you will complete the configuration of the dispenser firmware, download the compiled files to your laptop, and then use the tools to flash the microcontroller. At that point, the main components of the dispenser with the exception of the motor, will be fully operational. By the end of the module you will have: Modified the base firmware code to work with your specific account Compiled and downloaded the code files to your laptop Flashed the microcontroller with the compiled code on your laptop Verified it is communicating with AWS IoT by turning on and off the LED Steps to Complete Follow each step in order and use the Click to open for detailed step-by-step instructions if required.\n 7. Review Cloud Architecture  ObjectivesThis lab module will walk through how the dispenser, dispenser app, and coupled services interact. It will go into level of detail specific for the workshop. If you would like to review more details, please reference the Setting Up the Workshop documentation for deeper insights. By then end of this module you will have: An understanding of the relationship between the dispenser (Thing), your Cognito user, and the DynamoDB database tables that track and log dispenser activity and state.\n 8. Build Dispenser  Objectives This module provides necessary steps to build and test your drink dispenser Steps to Complete Follow each step in order and use the Open for detailed step-by-step instructions if required. Bill of Materials Verify that you have all the necessary parts. Some parts may already be installed from the previous labs, such as the 9V battery lead and ESP32-DevKitC development board into the controller board. - Base plate - 1/2\u0026quot; PVC Cap (white) - 1/2\u0026quot;x1' PVC pipe (orange) - Top, middle (with LED ring), and bottom plates for top assembly - 8 M3-6mm 25mm standoffs - 9 M3 Cap nylon nuts - 4 M3-6mm nylon screws - 4 M3-8mm nylon screws - 2 M3-12mm stainless steel screws - 1 M3 hex nut - Pump motor - 9V battery - 9v battery clip with JST-2 connector - Electronics controller board - ESP32-DevKitC development board Consult with image below for the material list: !\n 9. Dispense a Drink!  Objectives Okay, this is the moment of truth. You have: Setup your laptop to flash the dispenser. From Cloud9 compiled the firmware specific for your dispenser. Flashed the microcontroller and tested the cloud capabilities and built up enough credits to operate. Optionally built the dispenser and are ready to test. With all that completed, let\u0026rsquo;s dispenser a real liquid drink. Steps to Complete Follow each step in order and use the Click to open for detailed step-by-step instructions if required.\n "
},
{
	"uri": "https://cdd.example.com/docs/presenter/design_notes/message_flows.html",
	"title": "Message Flows",
	"tags": [],
	"description": "",
	"content": "Device and Application Message FlowsThe shadow document for devices tracks state of local resources. In the case of the motor board, this is led which maps to the second motor controller, which is not used. This give an indicator that things are working without having to activate the motor.\nThe led_ring is the round ring and count determine how many LED elements to light up, and the color is the RBG color for all active elements. Each of these below will always be in the desired state of the shadow and once online, in the reported state for the device.\n{ \u0026quot;led_ring\u0026quot;: { \u0026quot;count\u0026quot;: 0, \u0026quot;color\u0026quot;: \u0026quot;#RRGGBB\u0026quot; }, \u0026quot;led\u0026quot;: \u0026quot;on|off\u0026quot;, \u0026quot;dispense_time_ms\u0026quot;: 2500, } There are also a temporary request and response objects used to track command state. The cloud logic will create the request object in the desired state section of the shadow, and once processed by the device, it will create the response object in the reported state section. Finally, cloud logic will reconcile and clean up the shadow document of any entries left.\nBelow are what the request and response objects should look like. The command and requestId attribute and values must match. For the request object, the timestamp attribute is when the request was made, while in the response object it is when the dispenser completed the operation.\n{ \u0026quot;desired\u0026quot;: { \u0026quot;request\u0026quot;: { \u0026quot;command\u0026quot;: \u0026quot;dispense\u0026quot;, \u0026quot;requestId\u0026quot;: \u0026quot;1234-5678\u0026quot;, \u0026quot;timestamp\u0026quot;: 12345 } }, \u0026quot;reported\u0026quot;: { \u0026quot;response\u0026quot;: { \u0026quot;command\u0026quot;: \u0026quot;dispense\u0026quot;, \u0026quot;requestId\u0026quot;: \u0026quot;1234-5678\u0026quot;, \u0026quot;result\u0026quot;: \u0026quot;success\u0026quot;, \u0026quot;timestamp\u0026quot;: 45678 } }, } The following sequence diagrams show the flows for different uses. The first flows are device-to-cloud, then Rules Engine actions, and then API generated flows.\nDevice FlowsTurn on/off LEDUses the device shadow to set the desired state of an LED. The unused motor controller\u0026#8217;s associated LED can be set on or off, while the LED ring can be addressed with an RGB color and number of LEDs to light. All LED operations take place through the device shadow.\nAt creation, the LEDs are all set to a desired state of off. The dispenser hardware should read and honor the shadow settings for the LED.\nFigure 1. Turn on the LED In this flow:\nDispenser subscribes to shadow delta topic, e.g., $aws/things/123/shadow/deltaDispenser publishes desired state change to shadow update for led (LED for second motor controller)If there is a difference between desired and reported states, the delta, \"led\": \"on\" is sent to the dispenserDispenser enables the LED locallyDispenser then publishes teh reported state of LED1 to the shadow update topicRules engine matches update operation and invokes logging event action This is the same flow for led1 and led_ring. For led_ring, the attributes are the amount of LEDs to light (0-5) and the RBG color in hex, e.g., #ff0000 for full red.\nNote: The LED operation can be on or off.\n Activate DispenserUses the device\u0026#8217;s shadow desired state to send a command (request) to the dispenser. After the dispenser has completed the operation, it updates the shadow\u0026#8217;s reported state to acknowledge the request.\nFigure 2. Activate Dispenser In this flow:\nRequest - User clicks on \"dispense\" button in web applicationLambda is invoked for that requestDispenser record readIf there is a good balance and no in-process requests \u0026lt; 5 seconds old:Record a new request in the dispenser recordPublish the request object to the dispensers shadow desired stateLog a successful request eventReturn to the API/web app a success messageIf there is not enough credits or a dispense request is still valid (\u0026lt;5 seconds old):Log an errorReturn to the API/web app a descriptive error The response operation is decoupled from the request in that the dispenser may be in an offline state. Once online, the response flow continues:\nDispenser received a shadow update on $aws/things/shadow/123/delta or $aws/things/shadow/123/update/acceptedIf the timestamp of the request is older than 5 seconds:Add a response object to the reported state with a result=ERROR indicator (optional - if submitted no credits will be deducted)Discard the message and log locallyIf the request is current (less than 5 seconds old):Activate the motor for set durationIn parallel if possible, a response object to the reported state with the same requestIdThe response message triggers the Rules Engine which looks at the shadow document for a state.reported.response objects and if found invokes the Lambda functionLambda determines this is a rules invocation and not APIReads the dispenser recordIf there is a matching requestIddeduct $1.00, clear requestId, update dispenser recordLog successful dispenser operationsDelete (set to null) and request and response objects in the dispensers shadowIf no matching dispense requestId was foundLog error (should not arrive here)Delete (set to null) and request and response objects in the dispensers shadow The Lambda will also clear out a stale dispense request. There can only be one in-flight dispense request in the dispenser\u0026#8217;s record.\nNote: A dispenser may get a free pour if it receives the dispense command and then goes offline before publishing the response message.\n Rules Engine FlowsThese flows are subscriptions made by the rules, and the actions they take.\nLogging EventsThe logging rule monitors all messages published to events and events/#, and invokes a Lambda to persist the events into the DynamoDB EventsTable.\nFigure 3. General Event Logging There are three logging rules for the workshop, all which log events to the EventsTable. The LogShadowEvents rule monitors for shadow update documents, adds the topic which will identify the dispenser, then invokes the ProcessEvents Lambda function. Similarly for messages published to the events and events/nnn (dispenser ID) topics, the LogGenericEvents and LogDispenserEvents rules process the messages and invoke ProcessEvents.\nThe Lambda function parses the incoming details and creates the formatted entries that then published to the DynamoDB EventsTable.\n "
},
{
	"uri": "https://cdd.example.com/docs/presenter/prerequisites.html",
	"title": "Prerequisites",
	"tags": [],
	"description": "",
	"content": "We have strived to keep the amount of prerequisites to a minimum in order to setup the infrastructure for the workshop. Please ensure that all of these are completed before progressing to the next step.\n  An AWS account to be used to host the workshop services and participant IAM user accounts. It is recommended to use or create a new or sandbox account as the participants will have permissions to see resources.\n  Have a local Workstation or laptop available\nTo build and run the CloudFormation steps, you will need a workstation, an EC2 instance, or a laptop. All the steps are written and based on Linux/macOS. If you don\u0026rsquo;t have a similar environment, you may use an Amazon Linux based EC2 instance. No matter what you use, please ensure the following tools are installed:\n  AWS CLI with admin credentials (see below)\n  NodeJS \u0026gt;= 8.11.x and npm\n  Python \u0026gt;= 3.6 and pip\n  AWS Cloud Development Kit (CDK)\nThe following commands will verify that the command line tools are properly installed: $ aws iam get-account-summary # AWS CLI { \u0026#34;SummaryMap\u0026#34;: { ... } } $ node -v # NodeJS v12.8.0 $ npm -v # Node package manager 6.10.2 $ python --version # Python Python 3.7.4 $ pip --version # Python module manager pip 19.2.2 from ... $ cdk --version # CDK utility (from npm) 1.4.0 (build 175471f) \n    An AWS CLI named profile. The profile in ~/.aws/config should contain the target region, and the ~/.aws/credentials file should have an access key and secret access key with administrative access (or minimum to deploy and run the stack). The profile name cdk-user will be used throughout this guide.\n  A registered domain name managed by Route 53 in the workshop account. This can either be through registration in Route 53, or making Amazon Route 53 the DNS service for the domain. If we want the URL for the workshop to be cdd.example.com, in Route 53 there needs to be a public hosted zone for example.com.\n  To target the appropriate account, region and other aspects, the following entries need to be considered and changed in the config.json file (the default value used in this guide listed first):\n Region - us-west-2Region identifier, must support all AWS resources being used. HostName - cdd.example.comThe fully qualified domain name entry to be created from the Route 53 hosted zone details above (example.com). Note, subdomain entries can also be used such as cdd.foo.example.com, but must be created from Route 53. ProfileName - cdk-userThe AWS CLI profile name referenced above. It is used by the build and deploy steps to use the right account and credentials. AdminUserName - adminThe username to log into the web application for administrative purposes. AdminPassword - NO DEFAULT VALUEThis needs to be completed in the config.json file and is only used for web application related tasks, and not for AWS account activities. cloud9InstanceSize - t3.smallInstance size for each participants Cloud 9 environment. Select larger (or smaller) depending upon how long the Amazon FreeRTOS compilation should take. ParticipantLimit - 20The maximum amount of user accounts that can be created, after which, new account creation will fail. It is best to set this to 5-10% above total expected participants.    An Amazon Certificate Manager (ACM) validated server certificate in N. Virginia, to encrypt access to the web application. The certificate needs to be created in the N. Virginia region to work with Amazon CloudFront. Also, the issued certificate must support the fully qualified domain name you wish to use. For example, a certificate for *.example.com is valid for the domain name cdd.example.com, but would not work for cdd.foo.example.com since the wildcard is only matches the third element foo, and not the fourth one, cdd.\n   "
},
{
	"uri": "https://cdd.example.com/docs/participant.html",
	"title": "Workshop Participant",
	"tags": [],
	"description": "",
	"content": "Welcome Workshop Participant! The Connected Drink Dispenser, or CDD, simulates a fleet of physical devices managed and controlled by a cloud-based architecture. The physical device, which you will build, can dispense a drink from a standard bottle such as soda or water through a controlled air-pump, and uses an ESP32 microcontroller (MCU) as the brains of the operation. Connectivity to AWS IoT is done through a Wi-Fi network connection, and interaction and local device control is performed by an Amazon FreeRTOS application running on the MCU.\nTo simulate dispenser activities, a single page web application (SPA, or dispenser app) with user authentication is used. It can control dispensing a drink via the dispenser associated with the user, and to provide credits to other dispensers. This demonstrates how devices can be scoped down to limited permissions and actions, while still taking advantage of robust serverless applications.\nUsing This Documentation This section of the document covers the exercises you will be working through to completed the workshop. There are few things to note while walking through the modules:\n  Modules build on each other - Please ensure that each module is completed in-order, and if there are checkpoints at the end, each is complete and operational. Do not move onto the next lab until this is validated. If you do have any questions, please raise you hand for support.\n  Comprehension over completion - Each module will start with a set of objectives, a step-by-step walk through on how to complete. Besides the how, there will be a set of why takeaways which will be helpful in the future when using these skills.\n  Lab context - Some modules are more of seeing what happens when certain operations that place. These will be put into context for the overall architecture of the Connected Drink Dispenser workshop.\n  You can navigate either from the menu to the left, or by using the blue navigation arrows (\u0026laquo;/span\u0026gt; and \u0026gt;) to move forward or back a page.\nLet\u0026rsquo;s get started by navigating forward to the Lab Modules Page!\n"
},
{
	"uri": "https://cdd.example.com/docs/participant/lab_modules/2_laptop_setup.html",
	"title": "2. Laptop Setup",
	"tags": [],
	"description": "",
	"content": "Objectives In this lab you will configure your laptop for the workshop. By the end of the module you will:\n Have a local directory or folder to hold all the files required for your dispenser Have installed and tested a device driver to communicate with the microcontroller Downloaded a command line utility to program (flashed) the microcontroller Have an open terminal or command prompt ready to issue commands, and verified that the microcontroller appears as a serial device  The microcontroller is programmed, or flashed, via a USB serial connection from a computer or laptop. Based on the microcontroller chipset, a specific driver is required.\nEach persons laptop is unique and the general instructions may not work for a variety of reasons such as having a older version of the driver loaded, insufficient permissions to install, or older versions of Operating Systems. Please ensure that the checkpoint at the end has been completed prior to starting the next lab. If you run into problems, please ask for assistance from a workshop assistant.\n Steps to Complete Follow each step in order and use the Click to open for detailed step-by-step instructions if required.\n1. Create Local Folder Create a local folder called cdd that will contain all downloads and assets needed for the workshop. It is recommended to create this within your web browsers default download location. When asked to download resource X to cdd folder, save or move the files to that folder.\n  Click to open for detailed step-by-step instructions    Open a file browser for your operating system (Windows: Explorer, macOS: Finder) and navigate to the default download folder used by your web browser. Create a folder named cdd within Downloads and note the location Leave a file browser open as we will be using it to move files around in later modules.    2. Download and Install Serial Driver The microcontroller used in this workshop, the ESP32-DevKitC, has a built-in Silicon Labs CP210x serial controller. In order for you laptop to communicate with the microcontroller you need to download and install the CP210x USB to UART Bridge VCP Drivers for your operating system. Follow the instructions exactly, you may be required to provide permissions to the driver and in some cases restart you laptop to complete the installation process.\nUse the installer specific to the exact version of your operating system. Using the wrong driver will not work and may make it difficult to install the proper version later.\n   Click to open for detailed step-by-step instructions    Open a browser window to the the CP210x USB to UART Bridge VCP Drivers download page. Download the software (the Download VCP link) for your operating system. If in doubt, please verify the version and read the release notes to confirm. Once downloaded, follow the instructions to complete the installation of the driver.  Here are some tips for popular operating systems:\n Windows 10 - Unzip and use the installer for either 32-bit or 64-bit. The VCP driver may have been installed by Windows Update, but using the Silicon Labs provided driver will work with the ESP32-DevKitC. Windows 7/8/8.1 - Use the default driver, not the serial emulation one. The VCP driver may have been installed by Windows Update, but using the Silicon Labs provided driver will work with the ESP32-DevKitC. If the default driver does not work, you may try the other driver. macOS/OSX - Mount the DMG file, or use the legacy folder for OSX 10.9 or 101.10. NOTE: On MacOS 10.13 and later, the installation of the driver may be blocked. To unblock, open the System Preferences Security \u0026amp; Privacy pane and unblock the system extension. See Apple Technical Note TN2459 \u0026ldquo;User-Approved Kernel Extension Loading\u0026rdquo; for more information.    3. Download and Install esptool To be able to flash the firmware to the microcontroller we need to install a specific application called esptool. A pre-built executable can be downloaded here for macOS and here for Windows. Unzip or untar the file and place the file in the cdd directory.\nFor Linux users, or if you prefer to have it installed as a Python package, follow the instructions for your operating system to install the application. If installed correctly the command should accessible from any directory.\n  Click to open for detailed step-by-step instructions   Option 1 - Executable for macOS and Windows\n Save the macOS or Windows compressed esptool file to your browsers Downloads directory. Unzip or untar and move the esptool file (esptool for macOS, esptool.exe for Windows) from the esptool folder to the cdd folder. This will allow you to run esptool without having to add it to your PATH.  Option 2 - Install as Python Module\n Navigate to the esptool.py GitHub repository and scroll down to the installation instructions section. For your operating system, follow the instructions to install the Python modules. It is recommended to install in a virtual environment or in such a way so that is doesn\u0026rsquo;t affect your operating system\u0026rsquo;s Python installation.  Optional Installations\nIf you are unable to install the esptool or run it via the options above, there are optional versions available for different operating systems. Please note that these have not been tested, and there may be differences between the arguments referenced in the lab modules and the actual software.\n macOS - If you have brew installed, you can install esptool via brew install esptool. Ubuntu - Recent versions of Ubuntu have esptool as an installable package: sudo apt-get install -y esptool. Other mainline Linux distributions may also have similar packages for installation. All Operating Systems - esptool-ck has compiled versions, please check the releases section.    4. Open Command Line Interface and Test All Components Before testing, remove the ESP32 microcontroller (labeled as Provided ESP32) and USB cable from the zip-top bag:\nEnsure that you have installed both the esptool and the USB to serial device driver before continuing To interact with the microcontroller you will use a terminal window (macOS and Linux) or a command prompt (Windows). Create a terminal window and change to the cdd directory you created. Verify that you can run the esptool command, and then verify that when you connect the ESP32 via the USB cable that a new serial device is created.\nWhen you have verified the previous step, remove the USB cable from the laptop and microcontroller.\n   Click to open for detailed step-by-step instructions     For macOS or Linux, launch a terminal window, for Windows launch a command prompt.\n Windows - Launch a cmd.exe (Command Prompt). macOS -  + Space -\u0026gt; terminal.app Linux - Control + Alt + T    From the terminal window, run esptool and make sure it responds (the result doesn\u0026rsquo;t matter, just that the executable can be run):\n$ esptool.py -h usage: esptool [-h] [--chip {auto,esp8266,esp32}] [--port PORT] [--baud BAUD] ... $ For Windows the command would be esptool.exe, and depending if you installed or just downloaded the file, for macOS/Linux ./esptool.py, ./esptool or just esptool may be the syntax needed. Note what syntax worked, as you will need to use that for when you get to flashing the microcontroller.\n    5. Download or Configure Serial Monitor Tool For macOS and Linux, you will use the built-in screen utility to connect to and monitor the microcontroller. There is no configuration required.\n  Click to open for detailed step-by-step instructions for macOS and Linux     Check what serial ports are in use before connecting the ESP32.\n ls -l /dev/tty.* will show the ports. You should not see a tty.SLAB_USBtoUART entry yet. For Linux, ls -l /dev/tty.* and note the port numbers.    Connect the ESP32, then run the same commands and look for a new entries: that will be the port you will use when flashing and monitoring the microcontroller. When added to a MacBook Pro, a valid driver installation and good data+power USB connection would show this:\n$ # Before connecting ESP32 to laptop $ ls /dev/tty.* /dev/tty.Bluetooth-Incoming-Port $ # After connecting as above /dev/tty.Bluetooth-Incoming-Port /dev/tty.SLAB_USBtoUART   Run the following command and observe if output is showed in the terminal\n$ screen /dev/tty.SLAB_USBtoUART 115200 \u0026lt;a bunch of line should be printed\u0026gt;   To exit press press CTRL+a CTRL-\\ and confirm with y\n  Remove the USB cable from both the microcontroller and your laptop.\n    For Windows, you can either use a serial application already installed or download and use PuTTY.\n  Click to open for detailed step-by-step instructions for Windows Install of PuTTY     Download Putty from here or here.\n  Run the installation wizard and select all options:\n  Select Session in the left panel, and Serial in the radio boxes list in the right panel. Do not use the Serial entry in the left panel\n  Configure the Serial line using COMx port from above, and enter 115200 in the Speed field\n  Create the session by clicking on Open\n  Open the Console to see the microcontroller output.\n  Remove the USB cable from both the microcontroller and your laptop.\n    Checkpoints Please ensure the following checkpoints are validated before moving on to the next module.\n Folder cdd - Verify and note the location of the folder Serial driver installed and tested - When the ESP32 is connected, the driver is working if a new serial port is created (/dev/tty.SLAB_USBtoUART or similar for macOS, a COMx port for Windows) Serial Monitoring Tool - Either PuTTY for Windows or screen for macOS/Linux. When you see monitoring mentioned, this is the tool to use. Flash Tool - This is the esptool or esptool.py that you will use to flash the microcontroller Command line window left open for other lab modules  Outcomes Installation of device drivers, tool chains, and utilities such as esptool to interact with microcontrollers is complex, so why do we do it? Unlike cloud environments that can be stood up with infrastructure as code (IaaC), firmware development and testing takes place locally.\nBy completing and testing the installation of the tools in advance, we know that our environment is working properly. And if we need to fix or have another laptop or desktop to develop from, the steps to complete the setup are documented.\n"
},
{
	"uri": "https://cdd.example.com/docs/presenter/deploy.html",
	"title": "Deploy Stack",
	"tags": [],
	"description": "",
	"content": "This section covers the steps to locally build and then deploy the stack to your preferred region. All steps are completed within the deploy/ directory.\nModify Template Files Copy the deploy/config.json.default to deploy/config.json and modify the new file and change the following parameters with the values from the prerequisites section:\n Region - AWS region to deploy and run the stack (for example, us-west-2 from previous section). HostName - Fully qualified domain name for the stack to build and use, must not exist, it will be created. ProfileName - The name of the AWS CLI profile with administrative permissions.  Process Local Dependencies There are various python packages that need to be installed within the deploy/.env directory in order for CDK to run and process the stack. Follow these steps once to install the dependencies.\nChange to the deploy/ directory and activate the Python virtual environment.\n$ cd Connected_drink_dispenser/cdk $ source .env/bin/activate # sh or bash $ pip install -r requirements.txt Verify by running cdk synth which will return a long CloudFormation stack in YAML. As long as no errors were returned, the cdk synth command has verified dependencies and created the artifacts in the cdk.out/ subdirectory (don\u0026rsquo;t delete this directory).\nDeploy Stack via CDK and CloudFormation With the prerequisites and config.json set, run cdk deploy. This will take at least 30 minutes if not longer as there is a CloudFront (CDN) distribution involved. The final output should look like this:\n✅ cdd-workshop Outputs: cdd-workshop.StaticSiteBucket34E5D9AF = cdd.example.com-static-site cdd-workshop.APIEndpoint = https://xxxxxxx.execute-api.us-west-2.amazonaws.com/prod/ cdd-workshop.CognitoIdentityPool = us-west-2:38c0c443-xxx-xxxx-xxxx-692ebe311dfe cdd-workshop.UserPoolCognitoUserPoolIdArn107A6E54 = arn:aws:cognito-idp:us-west-2:123456789012:userpool/us-west-2_foo cdd-workshop.StaticSiteDistributionId8C64EF2A = E1MK8XXXX2S9X cdd-workshop.APIEndpoint1793E782 = https://xxxxxxx.execute-api.us-west-2.amazonaws.com/prod/ cdd-workshop.UserPoolCognitoClientId49B6D8C4 = 4hp8jitmd6virxxxxxo68p6 cdd-workshop.UserPoolCognitoUserPoolIdA08E3514 = us-west-2_foo Stack ARN: arn:aws:cloudformation:us-west-2:123456789012:stack/cdd-workshop/deadbeef-d008-11e9-8962-02dbab669d48 $ When completed, you should be able to navigate to https://cdd.example.com to verify that CloudFront is working. There will be a NoSuchKey error, which we will fix in the next step, but you can verify that the HTTPS certificate is in place.\nIf there are any errors running cdk deploy, the stack will automatically rollback and delete all the resources. Due to the CloudFront distribution, this will take 30 minutes or longer to complete. Review the error, correct, and re-run the deploy step. Most errors will either be related to permissions associated with the credentials used to deploy, or lack of one of the prerequisites.\nDeploy Application and Documentation With the stack deployed, we need to read some of the outputs from above, create the single page application, and then deploy it and this documentation. To do so, run the deploy_app.py script.\n$ python deploy_app.py Verifying local configuration files Reading CloudFormation stack parameters to create files for web application Clearing S3 bucket of ALL objects Copying web application to S3 |################################| xxx/xxx⏎ Copying online documentation to S3 |################################| 121/121⏎ "
},
{
	"uri": "https://cdd.example.com/docs/presenter.html",
	"title": "Setting Up the Workshop",
	"tags": [],
	"description": "",
	"content": "Welcome Presenter! This section will walk you through setting up the Connected Drink Dispenser workshop for participants. It covers the workshop setup, how procure and build hardware, and the approach to introduce the workshop and mentor the participants attending the workshop.\nDeploying the workshop opens your account to anyone registering for an account from the single-page app. Each participant (user) is provisioned with a Cloud9 instance that allows them to run processes and access the Internet. Only deploy the workshop over a period of time (hours, not days) where you can monitor activity in your account, and destroy the workshop once completed to secure resources.\n Each section covers details for understanding, setting up, and presenting the workshop. Follow each of these sections in order to fully build the workshop.\n Prerequisites to host the workshop for one or multiple runs. Building and deploying the workshop cloud assets. Procuring drink dispenser hardware. Presentation tips and FAQ for supporting participant. Layout of the repository.  Quick-start Using Cloud9 Follow these steps to deploy from a Cloud9 instance in the account where you wish to run the workshop:\n  Ensure a Route 53 hosted public zone is setup for a private domain name you have registered. The domain example.com is used below.\n  Launch a Cloud9 IDE from an account with all the IAM permissions needed to deploy the Cloud Development Kit (CDK) stack, from the region where you want to deploy the workshop. As there are a lot of IAM related permissions needed, the AWS managed permissions group, AdministratorAccess, has the necessary permissions.\n  Open a new terminal, install dependencies, clone this repository, and create the connected-drink-dispenser-workshop/deploy/config.json file from the template.\n### Copy and paste these lines into terminal cd ~/environment/ npm install -g cdk npm install -g yarn git clone https://github.com/aws-samples/connected-drink-dispenser-workshop.git cd connected-drink-dispenser-workshop/deploy/ sudo pip-3.6 install -r requirements.txt cp config.json.default config.json ### end of copy/paste   Update the config.json file\u0026rsquo;s values and save the file when complete:\n ProfileName - Change to default (this uses the permissions from our user account in Cloud9) AdminPassword - Enter the value for the dispenser app admin user, must include lower case, upper case, and a number Region - Set to the region you want the workshop to be deployed (should be the same as where Cloud9 was launched) Hostname - Enter the fully qualified domain name to use for workshop for the Route 53 hosted zone (e.g., cdd.example.com)    From the terminal, bootstrap the CDK into the region (optional if you are already using CDK in that region) with the command cdk bootstrap:\ncdk bootstrap Bootstrapping environment aws://ACCOUNT/REGION... CDKToolkit: creating CloudFormation changeset... 0/2 | 3:21:24 PM | CREATE_IN_PROGRESS | AWS::S3::Bucket | StagingBucket 0/2 | 3:21:25 PM | CREATE_IN_PROGRESS | AWS::S3::Bucket | StagingBucket Resource creation Initiated 1/2 | 3:21:47 PM | CREATE_COMPLETE | AWS::S3::Bucket | StagingBucket 2/2 | 3:21:49 PM | CREATE_COMPLETE | AWS::CloudFormation::Stack | CDKToolkit Environment aws://ACCOUNT/REGION bootstrapped.   Deploy the workshop with the command cdk deploy. This will create a lot of updates as the stack progresses and will take 30-50 minutes to complete due to the CloudFront deployment:\n$ cdk deploy ... LIST OF RESOURCES ... Do you wish to deploy these changes (y/n)? y cdd-workshop: deploying... Updated: asset.d58800906a30c9e60c2dc7e40199f78f18842fa61a81094dd212ef1d9c4607a7 (zip) ... BUILD STEPS ... cdd-workshop.StaticSiteDistributionId8C64EF2A = E5J4ADZ0ZK1C5 cdd-workshop.UserPoolCognitoClientId49B6D8C4 = 2b38h8da7dds832qvio3vkds5b cdd-workshop.UserPoolCognitoUserPoolIdA08E3514 = us-west-2_bnzrtUys3 Stack ARN: arn:aws:cloudformation:us-west-2:904880203774:stack/cdd-workshop/832c88d0-1b7c-11ea-b1f9-02b80ff4b548 $ If you see errors or CREATE_FAILED messages, review the reasons, which most likely will be permissions related. At this point the CDK will attempt to rollback and delete the deployment of resources. You may need to go into CloudFormation and delete the stack manually or issue the command cdk destroy. To resolve permissions errors, add the needed permissions to your account, and then close the Cloud9 IDE web page and relaunch from the console to refresh permissions.\nWith expanded permissions, attempt again to deploy the stack until the success message above is seen.\n  Finally, issue the command python deploy_app to build the single page application, and upload all resources to the S3 origin bucket:\n$ python deploy_app.py ... BUILD AND UPLOAD STEPS DONE Build complete. The dist directory is ready to be deployed. INFO Check out deployment instructions at https://cli.vuejs.org/guide/deployment.html Done in 65.14s. Copying Single page web application to S3: 36 files [00:05, 6.22 files/s] Copying Credential C formatter page to S3: 6 files [00:00, 79.67 files/s] Copying Online documentation to S3: 446 files [00:13, 33.56 files/s]   At this point, the stack if fully deployed and ready to start! Once the workshop is over, either delete via CloudFormation or from the same Cloud9 IDE, issue the command cdk destroy from the deploy directory.\n"
},
{
	"uri": "https://cdd.example.com/docs/participant/lab_modules/3_create_account.html",
	"title": "3. Create Account/Resources",
	"tags": [],
	"description": "",
	"content": "ObjectivesThis lab module will walk though creation of user and account resources, and how to access your unique resources. By the end of the module you will have:\nCreated and verified a user accountUnderstood what takes place during account creationKnow where to navigate in order to download and access your specific resources such as certificate and private key, and access other user details.Been introduced to UML sequence diagrams used to illustrate operations. Resource Creation ProcessWhen you first go through the user creation process, there are no resources created in advance. Once you log in for the first time, the API call that returns your resources will notice there are none and will go about creating them. At a high level, the process looks like this:\nUser John Doe registers and verifies new account jdoeThe user is created in Cognito User Pool and a valid JSON web token is returnedAs this is the first login, the /getResources method is called which invokes a Lambda functionThe function creates all of the unique resources for John on a per-service basis. As a result the following resource get created:An AWS IoT thing (the dispenser) and an associated certificateAn IAM user account with an automatically generated passwordA Cloud9 development environmentAll of the created resources are stored in a DynamoDB table that can only be accessed by the Lambda function. Finally, the /getResources returns John\u0026#8217;s specific details to be displayed in the dispenser app. This same sequence of events can also be presented using a sequence diagram. Each actor or participant is a column, and from top to bottom are the activities. See if you can associate the diagram above from this sequence diagram figure:\nFigure 1. Create User Resources Process Sequence diagrams are a consistent way to depict the flow of steps, especially for complex or multi-step operations. Depending upon what is being described, we are going to use a textual description or a sequence diagram in the lab modules.\nNow that you have an understanding of what is taking place behind the scenes, it\u0026#8217;s time to create your account!\n Steps to CompleteFollow each step in order and use the Click to open for detailed step-by-step instructions if required to create your account and access the resources.\n1. Register for an AccountOpen the URL provided in the presentation, and click on the create a new account link, or from the SIGN IN link, click on the Sign up link at the bottom of the Sign in page. For your account, enter Username, Password, and Phone number for your mobile phone to receive a validation code. Once you receive the verification code, enter it to complete the account sign up process. The mobile phone number is mandatory to validate your account. If you do not receive a code within a couple minutes, or do not have access to SMS, please ask the workshop assistants to manually validate.\nThe phone number must be in the \"+county code\" format. For instance, a US number would be \"+18005551212\" and for the UK \"+447624\u0026#8230;\u0026#8203;\", etc. If you have questions about the format, or are unable to receive an SMS message, please let one of the lab helpers know and they can complete the process for you.\n   Click to open for detailed step-by-step instructions   Navigate to the URL provided during the workshop overview. https://cdd.example.com will be used in these instructions, replace with what was provided.From the Welcome to the Connected Drink Dispenser Workshop! section, click on the create a new account link.\nChoose a username (an e-mail address works and will not be used to send any emails), password, and enter your mobile number for SMS verification code.\nThe page will refresh to the Confirm sign up page to enter the Confirmation code. Check your phone for the 6-digit code, enter it, and click CONFIRM. If successful you will directed to the Sign in page.   2. Initial Log InWith the account created and on the Sign in page, log in with your username/password. Initially you will see a Loading Resource page, and during this first log in, it will pause while the resources are created in the background.\nThere are various resources that are created, and this step normally takes around 30 second to upwards of 1-2 minutes. The reason for this is that different AWS services have different API call limits. With larger groups, you are simultaneously accessing the same resources, and API call may be throttled. If there are no changes after a minute or so, click on the log out icon (upper right in the menu bar), and log in again.\nOnce the resource creation is complete, the dispenser details page will load. Click the MY DETAILS button to open the resources section. Click on the CERTIFICATE FILE and PRIVATE KEY FILE, and save the files to your cdd directory on your laptop. If the files are automatically saved in the Download folder, move them to the cdd directory. Click the MY DETAILS button to hide the details.\nThe AMAZON ROOT CA1 FILE is not needed for this workshop, as the trusted certificate authorities are included in the Amazon FreeRTOS source code that you will be compiling. It is available here for use in other applications which you may wish use to emulate the dispenser (AWS IoT Thing).\n   Click to open for detailed step-by-step instructions   From the Sign in page, enter your your username and password and click LOG IN.The Loading Resource page will appear, followed after a few seconds a notice about resource creation. Do not refresh or click other links at this point. Resource creation can take approximately 30 seconds up to 1-2 minutes to complete. If there are no changes after a minute or so, click on the log out icon (upper right in the menu bar), and log in again.\nOnce the resources have loaded, toggle the MY DETAILS button to open the resources section. Click on the CERTIFICATE FILE, PRIVATE KEY FILE, and AMAZON ROOT CA1 FILE links and save the files to your cdd directory on your laptop. Click the MY DETAILS button to toggle closed.\nYour browser does not support the video tag. After downloading the files, note that your username appears in the upper right corner indicating you are logged in, and your unique dispenser number and credits are noted in the upper left.   CheckpointsPlease ensure the following checkpoints are validated before moving on to the next module.\nYou have successfully created a user account and saved the user username and password for future use.You have downloaded the certificate file (e.g., 34ea05fe7b-certificate.pem.crt), private key (e.g., 34ea05fe7b-private.pem.key) and optionally the root certificate CA (AmazonRootCA1.pem). This validates that all resources have been created in the cloud based on your username and assigned dispenser Id. OutcomesWe provided a detailed explanation of what happens during account and resource creation and showed a process for just in time registration of resources. In our case, it was the creation of the user account and resources, but a similar pattern can also be used to generate AWS IoT things, certificates, and policies just as a new device needs them, and not in advance.\nIf you are interested in how the resource creation process takes place, look at the code for the ApiGetResourcesFunction Lambda function when you are logged into the AWS Console.\n "
},
{
	"uri": "https://cdd.example.com/docs/participant/lab_modules/4_esp_setup.html",
	"title": "4. MCU Setup &amp; Test",
	"tags": [],
	"description": "",
	"content": "Objectives This lab module will walk you through connecting the components to test the operation of the dispenser without having to build the entire dispenser at this time.\nBy the end of this module you will:\n Have installed all the components needed to test the operation of the dispenser firmware with the cloud backend Have an understanding of what each component does Be able to communicate with the microcontroller via your laptop  Building the dispenser takes up a lot of room. For now, just remove the parts mentioned below and leave the rest in the zip-top bag. Promise: you will build the entire dispenser!\n A Few words on the Components The LED Ring is controlled by the microprocessor, and is used to display the status of the overall application. It is powered and controlled by the microcontroller and the firmware you will compile and flash.\nThe Controller Board serves a few functions.\n It acts as carrier for the microcontroller, and provides easy to use connectors for the other components being connected such as the LED Ring, external power, and the aquarium pump which will be installed later It can be powered either via USB, for the initial testing, or can be powered by an external battery, such as the 9V provided. The USB has too low voltage to drive the pump motor, and with some computers, even the LED Ring It also helps anchor all the components into the final build  Steps to Complete Follow each step in order and use the Click to open for detailed step-by-step instructions if required.\n1. Remove the Components to Use Take these five components from the zip-top bag (you should already have the ESP32 microcontroller and USB cable out from earlier testing):\n ESP32 Microcontroller USB Cable (Type-A to Micro USB data and power) Controller Board Ring LED 9 Volt Battery Lead  2. Connect the LED Ring and 9 Volt Battery Lead to the Controller Board Install the LED Ring into the WS2812 3-pin connector on the back Controller Board with the tab aligned with the connector slot. Turn over the Controller Board and attach the 9 Volt battery lead.\n  Click to open for detailed step-by-step instructions    Hold the LED Ring cable\u0026rsquo;s connector between your fingers. Align the tab on the connector with the slot on the 3-pin WS2812 labeled receptacle on the Controller Board. With slight pressure, insert the connector until it is fully in. Turn over the board and insert the 9V battery lead into the labeled GND 9V. The connector is keyed to only go in one way.    3. Install the Microcontroller into the Controller Board Align the microcontroller to the dual inline socket on the other side of the Controller Board, aligning the large metal square package over the 9 Volt battery extending out from the controller board. Make sure all pins on the ESP32 are aligned with the socket, the pin tips slightly inserted, then gently insert until all the way in.\nIt is very easy to accidentally bend the pins on the microcontroller. Turn over the Controller Board with the socket facing up, and then with your other hand gently position the microcontroller pins into the holes. Once all are in place, gently apply pressure equally (center of microcontroller works best) to insert all the way in. If you accidentally install backwards, place a finger underneath one end of the microcontroller and apply pressure to lift slightly. The do the same on the other end and alternate back and forth until the microcontroller is out of the socket.\n   Click to open for detailed step-by-step instructions    Hold the Controller Board in one hand with the socket side (opposite of the LED Ring connection) facing up. In your other hand hold the microcontroller and align the side with the large metal side with tab (antenna) to the Controller Board where the 9 Volt battery lead extends (not shown in pictures below\u0026ndash;see above). Align the pins on the microcontroller to the socket and put them in place lightly (do not apply any pressure). Ensure each pin is in a hole.  With gentle, even pressure, press the microcontroller in the socket until flush.     4. Connect the Microcontroller to Your Laptop and Test Serial Communication Insert the USB cable\u0026rsquo;s Micro USB connector end into the microcontroller, and the Type-A connector into your laptop. The red LED on the microcontroller indicates power, and the Ring LED may light up, but if it doesn\u0026rsquo;t, that is okay. Next, check that the serial port tested in the Laptop Setup module is there. Use the serial monitoring software to connect to the serial port. Press the button to the left of the USB connection (reset) and verify that you see text scrolling in the serial monitor window after each press. Exit your monitoring software.\nA Micro USB to Type-A cable is provided as part of the kit. If your laptop only has Type-C connector and you have a Micro USB to Type-C cable, make sure that it supports both power and data connections. The workshop presenter may have Micro USB to Type-C cables to loan out.\n   Click to open for detailed step-by-step instructions     Insert the USB cable into the microcontroller, and then your laptop and verify that red LED on the microcontroller is lit, showing that the microcontroller is powered up.\n  Use the serial monitoring tool (either screen or PuTTY) that you installed in the previous lab, verify that the serial port for your laptop works. In some cases, especially in Windows, the COM port number might change after each connection. Check you are using the correct one.\n  Press the button to the left of the USB connection and verify you see text after each press. It should look similar to this:\nrst:0x1 (POWERON_RESET),boot:0x13 (SPI_FAST_FLASH_BOOT) configsip: 0, SPIWP:0xee clk_drv:0x00,q_drv:0x00,d_drv:0x00,cs0_drv:0x00,hd_drv:0x00,wp_drv:0x00 mode:DIO, clock div:2 load:0x3fff0018,len:4 load:0x3fff001c,len:6340 load:0x40078000,len:11276 load:0x40080000,len:6084 entry 0x4008032c I (28) boot: ESP-IDF v3.1.3-13-g44a799c47 2nd stage bootloader I (28) boot: compile time 18:50:42 I (28) boot: Enabling RNG early entropy source... I (34) boot: SPI Speed : 40MHz I (38) boot: SPI Mode : DIO I (42) boot: SPI Flash Size : 4MB I (46) boot: Partition Table:   Exit the monitoring program. You may leave the microcontroller attached if you like.\n    If after connecting the microcontroller, the controller board, and the LED, you get errors about insufficient power or the red LED doesn\u0026rsquo;t not stay lit, your laptop or USB adapter may not be able to provide sufficient power. In that case, remove the microcontroller and connect a 9 volt battery to the controller board. It is connector under the microcontroller and not the one on the back next to LED Ring connector.\n Checkpoints Please ensure the following checkpoints are validated before moving on to the next module.\n The LED Ring and the microcontroller are connected to the Controller Board. The microcontroller has power when connected to your laptop and that the onboard LED is lit and there are not messages indicating insufficient power. You can see text via the serial monitoring tool when you press the reboot button. You have exiting PuTTY or screen (CTRL-a CTRL-\\, the y).  Outcomes Why are we only installing a few pieces of the entire dispenser instead of building it now?\nWhen doing embedded software development, it is easier to work first with a microcontroller development kit and the accessories you will be controlling. Normally this would be done with a breadboard or some other development kit (devkit). However, for those that are not familiar with that process, using the minimum pieces now will allow us to incrementally test the system up to the final build of the dispenser.\n"
},
{
	"uri": "https://cdd.example.com/docs/participant/lab_modules/5_cloud9_setup.html",
	"title": "5. Cloud9 Dev Environment",
	"tags": [],
	"description": "",
	"content": "Objectives This lab module will walk you through how to launch the Cloud9 IDE and download the device firmware source code. By the end of the module you will have:\n Installed the toolchain needed to compile and link the source code for the dispenser. Cloned the workshop repository which includes the dispenser firmware source code. Installed the supporting tools needed to compile.  The AWS Cloud9 Integrated Development Environment (IDE) is a service that runs on EC2 and provides a interactive and consistent development environment. You interact with it via a web browser, and it allows for command line access, a folder tree, and the ability to upload and download files between it and your local laptop.\nUsing Cloud9 is good because it gives a consistent compilation experience no matter the model or age of your laptop. It compiles within a couple minutes (older laptops can take 15 minutes or longer), and if compile times become too long, you can change the underlying instance size to obtain even more CPU or memory resources.\nSteps to Complete Follow each step in order and use the Click to open for detailed step-by-step instructions if required.\n1. Open New Browser Tab to Cloud9 Service and Launch IDE From the dispenser app, open the MY DETAILS section and open a new browser tab or window to the Sign-in URL, then login in with the credentials provided. From the AWS Console, open a new tab to the Cloud9 service. From the Your Environments menu, click on the Open IDE button for your user. This will open a new tab with the IDE and start up the EC2 instance (it may take a minute to fully launch).\n  Click to open for detailed step-by-step instructions     In the dispenser app, open the MY DETAILS section and click on the Sign-In URL to open a new browser tab.\n  Use the username and password credentials from the web app to log into the AWS Console.\n  From the console, click on Services from the top left menu bar, then in the Find a service by name or feature type Cloud9 and right- click on the drop-down service name and select Open Link in New Tab (or something similar).\n  On the Cloud9 tab, click on the Your Environments menu, click on the Open IDE button for your user. This will open a new tab with the IDE and start up the EC2 instance (it may take a minute to fully launch).\n    2. Install Dependencies Needed For Compilation With the IDE open, close the Welcome tab, and the click the green circled plus icon and select New terminal which will open a command line in the ~/environment directory. Copy and paste the following lines in the terminal window to install the dependencies and the Xtensa toolchain for the microcontroller (ESP32). The final commands will add the toolchain to your PATH so the build process can execute correctly.\n# Install OS utilities needed by toolchain sudo yum -y install flex gperf # Install Python modules (also used by toolchain) sudo pip install argparse cryptography serial pyserial cmake # Install the 64-bit version of the Xtensa ESP32 toolchain cd ~/environment wget https://dl.espressif.com/dl/xtensa-esp32-elf-linux64-1.22.0-80-g6c4433a-5.2.0.tar.gz mkdir ~/environment/esp cd ~/environment/esp tar xvfz ../xtensa-esp32-elf-linux64-1.22.0-80-g6c4433a-5.2.0.tar.gz cd ~/environment # Finally, add the toolchain path to your profile echo \u0026#39;PATH=$PATH:$HOME/environment/esp/xtensa-esp32-elf/bin\u0026#39; \u0026gt;\u0026gt; ~/.bash_profile source ~/.bash_profile # ============= Finished installation of dependencies ============= 3.Clone Workshop Repository The device firmware resides in the workshop\u0026rsquo;s GitHub repository. Copy and paste the following lines to clone the repository locally and change to the directory where the compile operations will take place.\ncd ~/environment git clone --depth 1 https://github.com/aws-samples/connected-drink-dispenser-workshop.git cd connected-drink-dispenser-workshop/device_firmware # ============= Finished installation of Connected Drink Dispenser repository ============= 4. Verify Default Compilation To verify that all components are in place, run the following commands to create the build environment in the device_firmware directory, then change to the build directory (it will be created in root of the repository, at ~/environment/connected-drink-dispenser-workshop/build).\nRun each of these commands and verify they completed without errors (warnings are okay).\ncd connected-drink-dispenser-workshop/device_firmware cmake -DVENDOR=espressif -DBOARD=esp32_devkitc -DCOMPILER=xtensa-esp32 -S . -B ./build This should only take a few seconds and end with no errors. Then run the make process:\ncd build make all -j4 cd .. Again verify there were no errors. The final output of the build step should look like this:\n... [100%] Building C object CMakeFiles/aws_demos.dir/demos/wifi_provisioning/aws_wifi_connect_task.c.obj [100%] Linking CXX executable aws_demos [100%] Built target aws_demos Scanning dependencies of target app [100%] Generating ../aws_demos.bin esptool.py v2.6 [100%] Built target app As a result of the build process, files have been created in ~/environment/connected-drink-dispenser-workshop/build. Among these there is also the the firmware that will be flashed onto the microcontroller.\nCheckpoints Please ensure the following checkpoints are validated before moving on to the next module.\n In the Cloud9 IDE:  There is a file named aws_demos.bin in ~/environment/connected-drink-dispenser-workshop/build. There were no errors (warnings are okay) in either the cmake or make all steps.    Outcomes We used a reproducible method (all the commands above can be automated) to create a development environment and toolchain build process. By doing this, you can always recreate the environment if something gets corrupted. Having the ability to quickly iterate in changes is an important factor in developing firmware.\n"
},
{
	"uri": "https://cdd.example.com/docs/presenter/repository.html",
	"title": "Repository Layout",
	"tags": [],
	"description": "",
	"content": "Repository Layout An understanding of the repository is not required to run the workshop, but can be helpful when deploying the cloud assets or to understand supporting resources. The Connected Drink Dispenser Repository directory structure looks similar to this:\n├── deploy \u0026lt;--- Build and deploy the CloudFormation stack ├── dispenser_app \u0026lt;--- Single Page App (SPA) ├── docs \u0026lt;--- Participant and presenter docs ... └── README.md \u0026lt;--- Main GitHub documentation page The main directories of interest are:\n deploy - Creates and optionally deploys all assets to the cloud for the workshop. dispenser_app - The SPA for managing per-workshop resources (admin user) and the web app for participants to interact with the device. docs - The source files to create the documentation site for inclusion into the main web site along side the dispenser app. You are current here!  "
},
{
	"uri": "https://cdd.example.com/docs/participant/lab_modules/6_flash_and_test.html",
	"title": "6. Develop, Flash, &amp; Test MCU",
	"tags": [],
	"description": "",
	"content": "Objectives In this lab module, you will complete the configuration of the dispenser firmware, download the compiled files to your laptop, and then use the tools to flash the microcontroller. At that point, the main components of the dispenser with the exception of the motor, will be fully operational.\nBy the end of the module you will have:\n Modified the base firmware code to work with your specific account Compiled and downloaded the code files to your laptop Flashed the microcontroller with the compiled code on your laptop Verified it is communicating with AWS IoT by turning on and off the LED  Steps to Complete Follow each step in order and use the Click to open for detailed step-by-step instructions if required.\n1. Modify the Source Files for Your Dispenser The X.509 client certificate and private key you downloaded earlier to your laptop\u0026rsquo;s cdd directory uniquely identify your dispenser from all others. In order to communicate to AWS IoT core, the firmware must be configured with this information. To do so, you need to modify two of the source files in in device_firmware/demos/include with the following:\n   Firmware Source File #define Statement in File Content     aws_clientcredential.h clientcredentialMQTT_BROKER_ENDPOINT AWS IoT Endpoint value from MY DETAILS section of dispenser app   aws_clientcredential.h clientcredentialIOT_THING_NAME Your assigned dispenser name (3-digit number) to use when connecting to the MQTT broker   aws_clientcredential.h clientcredentialWIFI_SSID WiFi network name provided by workshop presenter   aws_clientcredential.h clientcredentialWIFI_PASSWORD Provided password for the WiFi network   aws_clientcredential_keys.h keyCLIENT_CERTIFICATE_PEM Converted X.509 certificate (nnn-certificate.pem.crt) content from Credential Formatter   aws_clientcredential_keys.h keyCLIENT_PRIVATE_KEY_PEM Converted certificate private key nnn-private.pem.key content from Credential Formatter    In Cloud9, navigate to the device_firmware/demos/include folder, then double-click on the two files above and modify the contents. To modify the X.509 certificate and private key, use the Credential Formatterand copy the converted PEM content into the file.\nThe content of the aws_clientcredential_keys.h file should look similar to the following before and after copying the converted content of the two PEM files:\nBEFORE:\n#define keyCLIENT_CERTIFICATE_PEM \u0026quot;REPLACE_WITH_CONVERTED_CERTIFICATE_STRING\u0026quot; AFTER:\n#define keyCLIENT_CERTIFICATE_PEM \u0026quot;-----BEGIN CERTIFICATE-----\\n\u0026quot;\\ \u0026quot;MIICxjCCAa6gAwIBAgIVAJhkG3c6wT05SEZKJ3OsVHrQov6nMA0GCSqGSIb3DQEB\\n\u0026quot;\\ \u0026quot;IdbvOv7LLT9BD2Z8Mx9H/BhCd9ylpZEyQcl948GjEXgBDGdxUKFhrEfx\\n\u0026quot;\\ \u0026quot;-----END CERTIFICATE-----\u0026quot; Ensure that you update both the Certificate and Private Key sections. Leave the rest as-is.\nOnce both files are modified, save them from the Cloud9 IDE. You can leave the tabs open to quickly go back to the files if needed.\n  Click to open for detailed step-by-step instructions     In Cloud9, navigate to the device_firmware/demos/include folder then double-click the two source files to modify:\n  In each file reference above, replace the contents between the double-quotes. All values you need to replace start with \u0026quot;REPLACE_WITH_...\u0026quot;. For all values except keyCLIENT_CERTIFICATE_PEM and keyCLIENT_PRIVATE_KEY_PEM, you can simply copy and paste the value.\n  For the keyCLIENT_CERTIFICATE_PEM and keyCLIENT_PRIVATE_KEY_PEM values, use the Credential Formatter, then for PEM Certificate or Key browse to the downloaded certificate and private key (do each separately), then click on the Display formatted PEM string to be copied into aws_clientcredential_keys.h. That will display all the lines to replace for keyCLIENT_CERTIFICATE_PEM and keyCLIENT_PRIVATE_KEY_PEM respectively.\nHere are examples of what the WiFi and Certificate values should look like when done:\nBEFORE: AFTER:    For each file, click the tab the from the Cloud9 menu, save both files (File-\u0026gt;Save). Leave both files open as it will be easier to correct any potential errors.    2. Compile and Download the Code from Cloud9 After saving the updated files, click on the terminal window where you did the compile steps in the previous lab. Run the make command again which will pick up the file changes and recompile the firmware.\ncd ~/environment/connected-drink-dispenser-workshop/device_firmware/build make all -j4 In the Cloud9 file browser navigate to the connected-drink-dispenser-workshop/device_firmware/build folder and expand it. Scroll down and right-click on aws_demos.bin and select Download and save to your cdd directory. Do the same for the build/bootloader/bootloader.bin and build/partition_table/partition_table.bin files.\nIn your laptop\u0026rsquo;s cdd directory you should now have these three files.\n  Click to open for detailed step-by-step instructions     In Cloud9, click on the terminal window and rebuild the device firmware.\ncd ~/environment/connected-drink-dispenser-workshop/device_firmware/build make all -j4   In the Cloud9 file browser navigate to the connected-drink-dispenser-workshop/device_firmware/build folder and expand it.\n  Right-click on aws_demos.bin, select Download, and save the file to your cdd directory. Do the same in the bootloader folder for bootloader.bin, and in partition_table for partition-table.bin.\n  When completed, make sure that aws_demos.bin, bootloader.bin, and partition_table are saved and available in your laptop\u0026rsquo;s cdd directory.\n    3. Flash and Monitor the Microcontroller from Your Laptop The final step in the modify-\u0026gt;build-\u0026gt;download-\u0026gt;flash sequence is to flash the microcontroller. Connect the microcontroller to your laptop. Next, from the command prompt or terminal opened earlier, ensure you are in the cdd directory and then use esptool to flash.\nThe command esptool ... will be used. Use the syntax that works for your laptop installation (e.g., ./esptool.py, esptool, etc.).\n Run the flashing program replacing the --port with your value (default for macOS used below).\nesptool.py --chip esp32 --port /dev/tty.SLAB_USBtoUART --baud 921600 --before default_reset --after hard_reset write_flash -z --flash_mode dio --flash_freq 40m --flash_size detect 0x1000 bootloader.bin 0x20000 aws_demos.bin 0x8000 partition-table.bin You should see output similar indicated the firmware was flashed.\nesptool.py v2.8 Serial port /dev/tty.SLAB_USBtoUART Connecting........__ Chip is ESP32D0WDQ5 (revision 1) Features: WiFi, BT, Dual Core, Coding Scheme None Crystal is 40MHz MAC: 24:0a:c4:23:d6:5c Uploading stub... Running stub... Stub running... Changing baud rate to 921600 Changed. Configuring flash size... Auto-detected Flash size: 4MB Compressed 24272 bytes to 14397... Wrote 24272 bytes (14397 compressed) at 0x00001000 in 0.2 seconds (effective 1140.8 kbit/s)... Hash of data verified. Compressed 860384 bytes to 529993... Wrote 860384 bytes (529993 compressed) at 0x00020000 in 8.0 seconds (effective 859.5 kbit/s)... Hash of data verified. Compressed 3072 bytes to 118... Wrote 3072 bytes (118 compressed) at 0x00008000 in 0.0 seconds (effective 3733.3 kbit/s)... Hash of data verified. Leaving... Hard resetting via RTS pin... At this point the microcontroller will reset and your code will be running on it! To verify that the process was performed correctly, start your serial monitoring program (PuTTY or screen). Reset the microcontroller via the button right to the Micro USB connector, and view the output. A properly configured microcontroller will have an I (nnn) WIFI: SYSTEM_EVENT_STA_CONNECTED message indicating it connected to the WiFi network, and then [ShadowTask] operations with SUCCESS, indicating that it is communicating with AWS IoT.\nIf you need to correct any errors in the firmware, ensure to exit your screen session (Ctrl-a+Ctrl-\\) or close the console window in PuTTY before re-flashing it since the serial port can only be used by one process at the time.\n  Click to open for detailed step-by-step instructions     Connect the microcontroller to your laptop and ensure the red LED is lit and that the serial port is available.\n  From your command prompt or terminal in the cdd directory, flash the microcontroller with esptool.\nesptool.py --chip esp32 --port /dev/tty.SLAB_USBtoUART --baud 921600 --before default_reset --after hard_reset write_flash -z --flash_mode dio --flash_freq 40m --flash_size detect 0x1000 bootloader.bin 0x20000 aws_demos.bin 0x8000 partition-table.bin Look for the Hash of data verified messages.\n  macOS/Linux: Start your serial monitoring program screen and connect to the microcontroller. Press the reset button to the left of the USB connector and nearest the red LED. Look for startup text containing I (nnn) WIFI: SYSTEM_EVENT_STA_CONNECTED and after a short time, [ShadowTask] operations with SUCCESS.\n### \u0026lt;--- Comments, not part of microcontroller output ### First messages rst:0x1 (POWERON_RESET),boot:0x13 (SPI_FAST_FLASH_BOOT) configsip: 0, SPIWP:0xee clk_drv:0x00,q_drv:0x00,d_drv:0x00,cs0_drv:0x00,hd_drv:0x00,wp_drv:0x00 mode:DIO, clock div:2 load:0x3fff0018,len:4 load:0x3fff001c,len:6372 load:0x40078000,len:11684 ho 0 tail 12 room 4 load:0x40080000,len:6112 entry 0x40080330 I (30) boot: ESP-IDF v3.1.5-105-g7313c836a5 2nd stage bootloader I (30) boot: compile time 23:19:39 I (30) boot: Enabling RNG early entropy source... # WiFi startup 2 7 [main] Connecting to network I (284) wifi: wifi driver task: 3ffbb758, prio:23, stack:3584, core=0 I (284) system_api: Base MAC address is not set, read default base MAC address from BLK0 of EFUSE I (284) system_api: Base MAC address is not set, read default base MAC address from BLK0 of EFUSE I (304) wifi: wifi firmware version: 3c46a62 I (1554) wifi: connected with SSID_NAME, channel 1 I (1554) wifi: pm start, type: 1 # !!! Look for this I (1554) WIFI: SYSTEM_EVENT_STA_CONNECTED # Connection to AWS IoT Core and successful communication with the device shadow 54 985 [ShadowTask] [INFO ][MQTT][9850] (MQTT connection 0x3ffb6208) MQTT PUBLISH operation queued. 55 1006 [iot_thread] [INFO ][Shadow][10060] Shadow UPDATE of 100 was ACCEPTED. 56 1006 [ShadowTask] Successfully performed update. 57 1006 [ShadowTask] Free mem: 129952 NOTE: The screen command will take full control of the terminal. The fully exit, use the Ctrl-a+Ctrl-\\ to kill all windows. You can also use your arrow keys to navigate up by entering Ctrl-a+ESC. There are good primers on how to use screen.\n  Leave the microcontroller and the LED Ring connected for the next module.\n    Checkpoints Please ensure the following checkpoints are validated before moving on to the next module.\n Firmware build with no errors in Cloud9 You downloaded and flashed the firmware with no errors You can monitor and see the dispenser connect to the WiFi network and establish a successful session to AWS IoT Core You have left the microcontroller connected for the next lab  Outcomes In this lab we went through all the normal steps of firmware development\u0026ndash;albeit as all manual steps. The process is similar to normal software development where you write code, compile, debug, and then repeat. In the case of firmware development, especially when working with hardware peripherals, the added step is flashing the firmware to development board.\nWhile Cloud9 is a fully integrated development environment, we only used it to edit and build the firmware, and have not taken full advantage of its capabilities.\nWhile we used manual processes to illustrate the various steps, we would normally automate and use specific tools to make the development process more streamlined, consistent, and to reduce errors. All of the steps completed manually can be automated. In a more automated environment, the development process could operate in this manner:\n Developer uses local IDE with integrated test and debugging tools (non-physical) to write code, commits to source control Source control commit triggers AWS CodeBuild with toolchain image to compile code and update the .bin files to an Amazon S3 bucket. Local workstation with attached hardware receives notice of new firmware, downloads, and flashes to microcontroller. Local workstation places serial or debugger ports into monitor mode, resets the microcontroller and it runs through it\u0026rsquo;s test. Monitor output reviewed by developer to make next set of changes or corrections.  By understanding what the development process looks like in this lab module, you can automate any series of steps slowly to add consistency and repeatability to your development processes.\n"
},
{
	"uri": "https://cdd.example.com/docs/participant/lab_modules/7_investigate_cloud.html",
	"title": "7. Review Cloud Architecture",
	"tags": [],
	"description": "",
	"content": "ObjectivesThis lab module will walk through how the dispenser, dispenser app, and coupled services interact. It will go into level of detail specific for the workshop. If you would like to review more details, please reference the Setting Up the Workshop documentation for deeper insights.\nBy then end of this module you will have:\nAn understanding of the relationship between the dispenser (Thing), your Cognito user, and the DynamoDB database tables that track and log dispenser activity and state.Seen how the dispenser Thing uses the Device Shadow Service for AWS IoT to get notified of the requested state changes, and how it uses to acknowledge a dispense request with a dispense response.Tested a dispense operation and monitored what takes place in different scenarios.Reviewed dispenser activity both in the DynamoDB EventsTable and in the dispenser app logging.An understanding of how the dispenser app along with the API Lambda functions control how to give credits to others dispensers, as well as ensuring that a dispense event can on;y be initiated when there sufficient credits. Steps to CompleteFollow each step in order and use the Click to open for detailed step-by-step instructions if required.\n1. Understand the AWS IoT Thing, Cognito User, and DynamoDB Table RelationshipsAs this solution is designed as a software-as-a-service (SaaS) environment, there needs to be a specific relationship between all of the resources to help enforce the security and operational controls of the actions. At a high level this is how the resources are associated with each other:\nFigure 1. Relationship between services Each thing has a unique X.509 client certificate for authentication allowing the dispenser to connect to AWS IoT and publish and subscribe to the MQTT topics specific for that dispenser. This authorization of MQTT topics comes from a common policy attached to the certificate that uses substitution variables that read the Common Name value from the X.509 certificate which contains the dispenser Id. This allows for an easier management of the authorization policies, as a single policy can be used for all dispensers. The relationship between the dispenser and the user is modeled into a Cognito User attribute, custom:dispenserId, that is read for every API call. Finally, your dispenser has an entry in the DynamoDB DispenserTable that tracks the credit balance and any in-flight or stale command operations.\nGo to the AWS Console to review the relationships for your dispenser and your own user in the following AWS services:\nAWS IoT Core - View your thing, the attached certificate details, and the policy associated with the certificate. Also, view the other security policy that is associated with your Cognito user (used to monitor update events).Amazon Cognito - From Manage User Pools, select the workshop-users, Users and Groups, then select your username. Note the custom:group and custom:dispenserId attribute values.Amazon DynamoDB - From the DispenserTable review the credits value for your dispenser via the dispenserId sort key. From the DispenserEvents table, query with the partition key equal to your dispenserId. As others start to create and operate their dispensers, filtering will limit to just your events.   Click to open for detailed step-by-step instructions   From the browser tab opened to the AWS Console, click on the Services menu dropdown (upper left next to AWS logo), and type in iot core, then click on IoT Core when the drop-down populates. This will direct you the the AWS IoT Core service page.\nTip: During the workshop you will be changing from service to service quite often. When navigating to a different service via the Service\u0026#8594;SERVICENAME, right-click on the service name and select \"Open in a new tab\" (or equivalent). This will have all the services referenced within a single browser window on separate tabs.\nClick on Get Started to take you to the main page, then select Manage from the left tab. Click on Skip tour. This will take you to the list of things. Either select your thing (same as dispenserId), or click on Search things, which is helpful for large amounts of items.From your things page, click on Security. This shows that you have a single X.509 certificate (long hash value) associated with your thing. Click on the certificate which will show details on it. Note that the Subject contains values that are parsed when the certificate is presented, and the value for CN (Common Name) is the dispenserId. This is how we can verify the identity of your device.To continue viewing the IoT relationships, from the Certificate page, click on Policies. This shows what IoT policies are associated with the certificate, and by relationship, to the thing. Click on the policy to view its content, which is a JSON document.\nNotice that all of the resources use the substitution variable ${iot:Certificate.Subject.CommonName} as part of the string. When a dispenser connects to AWS IoT the value in the client certificate CommonName, or CN, is used to replace the variable, making the policy resources unique to each dispenser. This allows for a single policy to used by all the dispensers.\nAbbreviated DispenserLimitedAccess Policy { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Condition\": { \"Bool\": { \"iot:Connection.Thing.IsAttached\": [ \"true\" ] } }, \"Action\": [ \"iot:Connect\" ], \"Resource\": [ \"arn:aws:iot:REGION:ACCOUNT:client/${iot:Connection.Thing.ThingName}\" ], \"Effect\": \"Allow\" }, { \"Action\": [ \"iot:Subscribe\" ], \"Resource\": [ \"arn:aws:iot:REGION:ACCOUNT:topicfilter/$aws/things/${iot:Certificate.Subject.CommonName}/shadow/*\", \"arn:aws:iot:REGION:ACCOUNT:topicfilter/$aws/things/${iot:Certificate.Subject.CommonName}/cmd/${iot:Certificate.Subject.CommonName}\" ], \"Effect\": \"Allow\" } ] }Next, from the Services menu, select Cognito, click Manage User Pools, and then click on the workshop-users pool. This is the service that manages the user account you created from the dispenser app. Under General Settings select Users and groups to display all of the user accounts. Search for your username and click on it. At the bottom you will notice a couple of custom: attributes. The first, custom:group denotes that your account is a general user account (extra credit, check out the admin user). The second attribute, custom:dispenserId shows your dispenserId value. These fields are passed whenever you make an API call from the dispenser app and used by the Lambda functions to validate what actions you are allowed to take.From the Services menu navigate to DynamoDB, which contains the database tables. Select Tables from the left menu, select the DispenserTable name, then select Items from the right pane. This table holds a single record for each dispenser. The most important field is credits, and should correspond to the value in the dispenser app (\"1\" in the table is $1.00 in the dispenser app). This record is modified every time someone gives you credits, or whenever you issue a dispense operation.Finally, select the DispenserEvents table from the left pane. You will see all the various log entries for all dispensers. To view just your dispenser\u0026#8217;s events, click on the Scan dropdown and change to Query, for Partition key enter your dispenser\u0026#8217;s value and click on Start Search.   2. Monitor Shadow Changes for a Simple Operation (toggle LED Ring status)The Device Shadow Service for AWS IoT is a service that can be used by things and applications to set and track the state of device. There are two main sections in the shadow document: the desired state and the reported state. In our solution the desired settings originate from the dispenser app. The dispenser acts upon them and set the correct reported state.\nFigure 2. Shadow state changes To see this in action, from the AWS Console navigate to your Thing in IoT Core, then select Shadow which will show the current shadow document. Note the led attribute in the desired and reported sections, which should be the same. Also notice the value for version in the metadata. This increments each time the shadow is updated. To see how the shadow is working, use the dispenser app to change the state of the LED by either toggling or setting to the other state. You will see the value for led has changed in the shadow document, in both desired and reported sections, and version has incremented.\nTo see how the shadow works when the device is in a disconnected state, unplug the microcontroller from your laptop. Now, in the dispenser app change the state of the LED and notice that the desired change to show the new value but that the reported state is still what the dispenser was in before being disconnected. Notice also that a new delta section has appeared in the document, containing just this led field. This is automatically calculated by the Shadow service. Plug the microcontroller back into your laptop. Once it has booted and connected AWS IoT, the LED will change to the desired state value and the dispenser will update the reported state. Since desired and reported states are the same, the delta state for the LED is removed.\n  Click to open for detailed step-by-step instructions   Note: In this expanded details section, we will only use a small subset of the entire shadow document and hierarchy to show the desired, reported, and delta sections.\n Navigate to IoT Core\u0026#8594;Manage\u0026#8594;Things\u0026#8594;Your Thing\u0026#8594;Shadow and review the shadow document. Note that the desired and reported sections are the same. This indicates that the device and requested state from the dispenser app are in sync. At the bottom of the shadow document review the value for version in the metadata. This increments each time the shadow is updated.\n\"desired\": { \"led\": \"off\", \"led_ring\": { \"count\": 5, \"color\": \"#FF8000\" } }, \"reported\": { \"led\": \"off\", \"led_ring\": { \"count\": 5, \"color\": \"#FF8000\" } }, ... \"version\": 100From the dispenser app, toggle or change the state of the LED (in this example from off to on). The dispenser app sets the desired state of the shadow, the dispenser reads this value, turns on the LED, and modifies the reported state to on. You may miss the update in the AWS Console, but check the metadata and notice that the value for version has increased by at least 2 (once for the dispenser app setting the desired state and once when the dispenser updated the reported state).\n\"desired\": { \"led\": \"on\", \"led_ring\": { \"count\": 5, \"color\": \"#FF8000\" } }, \"reported\": { \"led\": \"on\", \"led_ring\": { \"count\": 5, \"color\": \"#FF8000\" } }, ... \"version\": 102To see how the shadow works when the device is in a disconnected state, unplug the microcontroller from your laptop, then toggle or set the LED to the alternate state (in this case from on to off). Notice that the desired and reported states are different, and that there is a delta state which show only those differences. This is useful when you only want to focus on the changes between desired and reported states.\n\"desired\": { \"led\": \"off\", \"led_ring\": { \"count\": 5, \"color\": \"#FF8000\" } }, \"delta\": { \"led\": \"off\", }, \"reported\": { \"led\": \"on\", \"led_ring\": { \"count\": 5, \"color\": \"#FF8000\" } }, ... \"version\": 103To verify that the dispenser reads the shadow state upon restart, plug the dispenser back into your laptop and watch the shadow document. The dispenser will reconcile the states which will remove the attribute from the delta section (or completely remove it).\n\"desired\": { \"led\": \"off\", \"led_ring\": { \"count\": 5, \"color\": \"#FF8000\" } }, \"reported\": { \"led\": \"off\", \"led_ring\": { \"count\": 5, \"color\": \"#FF8000\" } }, ... \"version\": 105   3. Monitor Shadow MQTT topics for a Complex Operation (Dispense Drink)The shadow can also be used for more complex operations. While changing the state of the LED can be tracked via a single attribute, operations such as dispensing a drink are more complex and require multiple states such as request and response. The dispenser app initiates the dispense operation as a request, and when the dispenser completes the operation it, in turn, sets a corresponding response. We use a short, random, requestId value to match the correlate the request and response states.\nFigure 3. Tracking request/response using shadow As we cannot be sure that the dispenser is online, the dispenser app initiates the request and sets the desired state of the shadow with a request object containing the command to execute, a unique requestId, and the timestamp of when the user clicked \"Dispense a Drink\" in the dispenser app.\nTo verify, ensure the microcontroller is connected and LED operations take place. Next, use Test from the IoT Core console and subscribe to the topic $aws/things/dispenserId/shadow/# (replace dispenserId with your value) to track all shadow operations. Next, in the dispenser app click the Dispense! button (should still be green) to initiate a dispense operation. From the MQTT Client tab, you should see a few shadow topic messages. Scroll through and review how the first message sets the request object, and after the dispenser completes turning the pump (indicated by the animated LED pattern on the LED Ring) the reported state is updated with a response object that has the same requestId, and finally that the the request and response objects are both deleted from all shadow sections once the response has been reconciliated.\nIn this situation, we are using the shadow to track the status of a command sent to the dispenser, and the response once it acts upon it.\n  Click to open for detailed step-by-step instructions   Ensure the microcontroller is connected and responds to LED on/off events.Navigate to IoT Core\u0026#8594;Test and in the Subscription topic field, enter $aws/things/dispenserId/shadow/# (replace dispenserId with your value) and click Subscribe to topic.From the dispenser app, click the Dispense! button (should still be green) to initiate a dispense operation. This should turn on the Ring LED with an animated pattern for a short period of time and create a few messages in the MQTT Client, which indicates that the pump motor has been activated.Scroll to the bottom (oldest message) and look for the shadow update with desired state that has the first request object.\n{} initial requestThe next message by time will be the dispenser responding to the event publishing to the reported state a response object with the same requestId, signifying that it has completed that request (either with a success or failed indicator).\n{} request and responseOn the cloud side, the matching request and response objects trigger a Lambda function to log the transaction and clear out both objects from the shadow. This is essence reconciling the request to the response, and readying the dispenser for its next operation.\n{} cleared of both   4. Review Logging and CreditsOops! While testing how the Shadow works We used up all of our credits. Each dispense operation costs $1.00, and has been deducted from our dispenser credit, as shown by the dispenser app. Navigate to the DynamoDB DispenserTable and verify the credits match the dispenser app. Also, review the EventsTable for your dispenser (review the first steps in this lab if needed) to see the various logging entries made while testing the Ring LED and drink dispense test.\nWe use these tables as the source of truth for the status of our dispenser. While the dispenser code you compiled and installed could be modified, a dispense operation can only be performed if there are sufficient credits in the account (e.g., DynamoDB DispenserTable entry). We use the value of the dispenserId across the dispenser app (user account custom attribute), IoT Core (Thing name, Certificate CN) and DynamoDB DispenserTable (dispenserId key) to enforce the desired controls in the overall SaaS application.\n 5. Dispenser app OverviewThe dispenser app is your main interface for interacting with the dispenser, eg to dispense a drink, and to check its state. As the dispenser app is running inside your local browser, there are two methods that can be used to track what is the current status. We can continuously poll via an API to return the status, or use a callback mechanism to alert the dispenser app when something has changed. In our app we use the callback method, and specifically it does this by subscribing to the MQTT topics for your specific dispenser. This reduces the overall load on the SaaS service and demonstrates how we can use the features of AWS IoT Core to simplify the implementation.\nModern web browsers have the ability to monitor what is running locally. Our dispenser app has additional debug, or console.log() statements to give an indication when something is happening. From your browser, enable the Web Console (name varies based on browser), and select the Console tab. Now change the status of the LED. Every time you make a change, you will see an Received MQTT message with change in LED or credit status message. This is alerted when an incoming MQTT message of interest such as a shadow update occurs.\nThese messages then trigger the dispenser app to make an API call requesting the complete status of the dispenser (LED status, credits, etc.), which in turn updates the main dispenser page. If there are no changes being made, no MQTT messages are generated, and subsequently, no API calls are made to request an update to the dispenser app.\n  Click to open for detailed step-by-step instructions   Open the Web Console for your browser:FireFox: Select menu Tool\u0026#8594;Web Developer\u0026#8594;Web ConsoleGoogle Chrome: View\u0026#8594;Developer\u0026#8594;JavaScript ConsoleInternet Explorer 11: Either press the F12 key or from the Setting Wheel\u0026#8594;F12 Developer Tools\u0026#8594;ConsoleMicrosoft Edge: From upper right, select \u0026#8230;\u0026#8203;\u0026#8594;More tools\u0026#8594;Developer tools\u0026#8594;Console tabSafari: Preferences\u0026#8594;Advanced Tab\u0026#8594;Show developer menu in menu bar (close Preferences), Develop\u0026#8594;Show JavaScript ConsoleChange the status of the LED with the dispenser connected. Notice the Received MQTT message with change in LED or credit status lines. These a created when the dispenser app, which is subscribed to a set of MQTT topics receives a message. This is an indication that something may have changes and triggers the dispenser app to make an API call to the /status method, which returns the dispenser status parsed from the shadow document and the DynamoDB DispenserTable.If there are no changes being made, no MQTT messages are generated, and subsequently, no API calls are made to request an update to the dispenser app.   6. Share the Love!Now that we have shown how you interact with your dispenser via the dispenser app, let\u0026#8217;s build our credits up to a sufficient level to complete the rest of the lab. To do this, click on the Share the Love! panel underneath the LED status panel and follow the instructions. First, try giving credit to another dispenser number and monitor the Last credit response message (with or without browser logging). Next, try to give yourself credits and note that the gray button to the right does not change to SEND CREDIT!. This is a constraint built into the dispenser app. However, even if you were to make a direct API call, the backend will also deny the request.\nFinally, talk to your neighbors and ask them to start sending you credits. You may also see that as the credits increase, the LED Ring will also start to fill until you have at least $1.00, and after that the colors will changes as your balance goes above $2.00, $3.00, etc.\nIt is recommended that you have at least $2.00 or $3.00 to perform a couple dispenses with a fully built dispenser unit.\nGood work!\n CheckpointsPlease ensure the following checkpoints are validated before moving on to the next module.\nThe dispenser board operates correctly and you can toggle the LED Ring from the dispenser appA dispense operation enables the LED Ring with an animated pattern indicating the microcontroller activates the pump (motor control)You have an understanding of how the shadow document and DynamoDB tables are used to track state (LED) and perform command and control (request/response) operations OutcomesWhy do we use the shadow document for command and control, when it could also be done with regular MQTT messages? While either pattern are good practices, combining all of the operations into a single location makes it easier to follow for the workshop. As long as there is a way to track each request, the mechanism used doesn\u0026#8217;t matter.\nOne thing that we didn\u0026#8217;t discuss is the LED Ring. In this case, it is used to give a visual indication of the credit levels. From the dispensers perspective, it is another shadow attribute set to manage. But instead of being set by clicking buttons in the dispenser app, this value is programmatically set by the cloud services whenever there is a change in the credit state of a dispenser. This demonstrates that functionality in not static and can be modified in either device (dispenser) or the application (cloud-side).\n "
},
{
	"uri": "https://cdd.example.com/docs/participant/lab_modules/8_build_dispenser.html",
	"title": "8. Build Dispenser",
	"tags": [],
	"description": "",
	"content": "Objectives This module provides necessary steps to build and test your drink dispenser\nSteps to Complete Follow each step in order and use the Open for detailed step-by-step instructions if required.\nBill of Materials Verify that you have all the necessary parts. Some parts may already be installed from the previous labs, such as the 9V battery lead and ESP32-DevKitC development board into the controller board.\n- Base plate - 1/2\u0026quot; PVC Cap (white) - 1/2\u0026quot;x1' PVC pipe (orange) - Top, middle (with LED ring), and bottom plates for top assembly - 8 M3-6mm 25mm standoffs - 9 M3 Cap nylon nuts - 4 M3-6mm nylon screws - 4 M3-8mm nylon screws - 2 M3-12mm stainless steel screws - 1 M3 hex nut - Pump motor - 9V battery - 9v battery clip with JST-2 connector - Electronics controller board - ESP32-DevKitC development board Consult with image below for the material list: ![DispenserParts.jpg](/images/lab8_materials.jpg)  Base Plate Build   Build base plate:\n  Place M3x12mm stainless steel screw from inside of PVC cap as shown on the pictures below:\n  Thread it through the base plate hole closest to the edge and tighten with nylon cap nut from the bottom:\n  Place the hex nut inside PVC cap and align to the both holes (PVC and base plate):\n  Thread the M3x12mm stainless steel screw from the bottom and tighten (ask for help as this is the only step you will need a screwdriver):\n  It should look like this:\n  Take M3x6mm screws(the shorter ones):\n  Place them as show on the picture:\n  Tighten them by hand using M3 cap nuts from the bottom:\n  That completes the base assembly, now to build the top assembly.\nTop Assembly Build   Build top assembly stating with the motor:\n  Insert the motor as shown on the picture (make sure of mounting slots!)\n  Insert the M3x8mm hex standoff screws (longer ones) as show on the picture:\n  Tighten the M3x6mm-25mm standoffs from the bottom (do not over tighten it):\n  Take the middle plate with mounted LED ring and make sure that orientation is correct:\n  If not already attached, connect the 9 Volt batter cable\u0026rsquo;s JST-2 connector (the small white connector at the end of the cable) to the JST-2 socket marked GND 9V. (Make sure you are not using LiPo socket!!!):\n  Assemble controller board, middle plate and top plate with motor as shown:\n  Attach pump motor cable to the right pins on the controller board (furthest from the 9V connector):\n  Place ESP32-DevKitC back on the controller board as in the earlier labs:\n  Attach the other M3x6mm-25mm standoffs to secure motor and middle plate:\n  Align controller board in the slots on the top and bottom plate, attach bottom plate, and secure with nylon M3 cap nuts\n  Final result should look like this:\n  Thread vinyl tubes through bottle cap as shown. You might need to fold and squeeze the end of the tube to push it through:\n  Thread the larger vinyl tube from the bottom, middle plates to form a spigot and attach the smaller tube to the pump motor:\n  Very carefully insert 1/2\u0026rdquo; PVC pipe through top assembly (It is very tight to hold the top assembly by friction - ask for help if needed):\n  Fill the water bottle to approximately 50-75% full. Then attach the bottle to the assembly (vertical so as not to spill water) and adjust height as needed (again, there will be a lot of resistance when moving, be careful!):\n  Your drink dispenser is ready and should look similar to this:\n  Checkpoints Please ensure the following checkpoints are validated before moving on to the next module:\n Both vinyl tubes are airtight on the bottle cap The orientation of your microcontroller 9V cable connected to socket marked GND 9V  "
},
{
	"uri": "https://cdd.example.com/docs/participant/lab_modules/9_final_test.html",
	"title": "9. Dispense a Drink!",
	"tags": [],
	"description": "",
	"content": "Objectives Okay, this is the moment of truth. You have:\n Setup your laptop to flash the dispenser. From Cloud9 compiled the firmware specific for your dispenser. Flashed the microcontroller and tested the cloud capabilities and built up enough credits to operate. Optionally built the dispenser and are ready to test.  With all that completed, let\u0026rsquo;s dispenser a real liquid drink.\nSteps to Complete Follow each step in order and use the Click to open for detailed step-by-step instructions if required.\nThe following steps are if you are using your own dispenser. If you elect to use one of the pre-built ones, bring your microcontroller (the ESP32) to one of the pre-built stations. Be careful when removing from the controller board as its easy to bend the pins on the ESP32.\n 1. Power On the Dispenser After completing the build step, ensure there is liquid in the bottle, an empty cup underneath, then connect the 9 Volt battery instead of the USB cable for power. Wait until the dispenser is online by viewing the LED status. Now. from 6 inches or 6 feet away click DISPENSE! to pour yourself a drink!\nIf you wish to record this event for posterity, have someone else video you clicking DISPENSE! and having the dispenser pour the drink. Workshop assistants are glad to be your personal videographer if needed!\n If something goes wrong or doesn\u0026rsquo;t work, review the build steps from the previous lab, or ask a workshop assistant for help.\n  Click to open for detailed step-by-step instructions   . Ensure the dispenser unit is built and ready to go: .. Liquid in the bottle .. Top assembly securely screwed down and the output hose centered .. An empty cup under the output hose . Now connect the 9 Volt battery. This will provide power to the microcontroller and the aquarium motor. . Wait for the dispenser to fully come online by waiting for the LEDs to sync to the same status in the dispenser app. . Okay, with no physical connection between your laptop and the dispenser, click DISPENSE! to pour yourself a drink! . If the dispenser didn\u0026rsquo;t properly dispense a drink, perform some troubleshooting. .. Did you hear the motor whir or make noise? \u0026hellip; Yes: Check that the cap is securely seated on the bottle, there may be a air gap. \u0026hellip; No: Check the connection from the motor to the control board (disconnect the 9V battery first) .. If the LED ring does not change to the animated dispense pattern, verify there are enough credits and that the dispenser is online (toggle the LED) .. You can also ask a workshop assistant for help in figuring out the problem.\n  Checkpoints There is only one checkpoint to verify, and that is you successfully dispensed a drink!\nOutcomes Congratulations! You have successfully completed the Connected Drink Dispenser workshop. We hope that you enjoyed the session and came away with a general understanding in how you can incorporate AWS IoT services into an overall multi-user or multi-tenant AWS workload.\n"
},
{
	"uri": "https://cdd.example.com/docs/presenter/design_notes.html",
	"title": "Design Notes",
	"tags": [],
	"description": "",
	"content": "This is a compilation of designs used in the hardware and software.\nHardwareThe dispenser has four addressable components:\nled_ring: NeoPixel-based 5-element RGB LED ring. Can set the number of LEDs to light and the RGB color of all the LEDs.motor: Aquarium pump that can be actuated via the first addressable LED/motor h-bridge connectionled: Second addressable LED/motor h-bridge connection - used for initial testing (blinky)led2: Second addressable LED on the h-bridge board SoftwareAPI Methods\nTable 1. ApiTable MethodQuery parametersresponse bodyNotes/getResourcesNone{\"userName\": username, \"dispenserId\": \"100\", \"assets\": null}All responses will include userName and dispenserId. If there are no assets, that will be null, otherwise will be JSON object with the parameters: DynamoDB TablesTable 2. UserTable AttributePartition/Sort KeyFormatDefaultValueusernamePartitionstringnoneuser name from CognitonextDispenserId-string\"100\"The next dispenserId to vend, only added to the admin userdispenserId-stringnonevalue returned by default user adminassets-JSON objectvariesDefault: null, indicator to generate users resources The table is created empty. When the first user signs in, the Sign-in trigger will check for an admin user. If not present it will create one. The additional attributes for the admin user are:\nnextDispenserId - The number of the next dispenser to associate with a user These are the attributes for other users:\nPartition key: userName (string) - User name selected during Cognito sign-updispenserId (string) - Dispenser Id associated with user, IoT thing, etc.assets (object) - During sign-in, the /getResources method will create and populate Table 3. DispenserTable AttributePartition/Sort KeyFormatDefaultValuedispenserIdPartitionstring-3-digit unique value of dispenser, associated with usercredits-Number1Credits available to dispenser. Increment in 0.25 and deduct by 1.00 for a dispenseleaderBoardStatus-Number1Stage of completion. 1 is starting with user/dispenser created, 2 is next step, etc.leaderBoardTime-Number-Timestamp, without microseconds, when latest leaderBoardStatus stage changed.requests-list[] empty listList of active requests [\"requestId|command|timestamp|target\"] The table is created empty, and entries are created or deleted as individual users are registered. The table can be read by participants, but only updated by the admin user and Lambda functions.\nThis table tracks the status of credits, in-flight requests (requests), and other details regarding each dispenser.\nThe requests attribute contains a DynamoDB list of different in-flight requests. In this workshop, only the following is used (in JSON format):\n[ \u0026quot;1234-5678|dispense|12345678|device\u0026quot;, \u0026quot;4567-8901|anothercommand|87654321|device\u0026quot;, ] Both devices and applications interact with the list and construct a JSON message based on the contents, such as:\n{ \u0026quot;clientId\u0026quot;: \u0026quot;123\u0026quot;, \u0026quot;requestId\u0026quot;: \u0026quot;1234-5678\u0026quot;, \u0026quot;command\u0026quot;: \u0026quot;dispense\u0026quot;, \u0026quot;timestamp\u0026quot;: \u0026quot;12345678\u0026quot;, \u0026quot;target\u0026quot;: \u0026quot;device\u0026quot; } This is the representation of the first entry in the list. As requests are completed, the entity that validates the completion will remove them from the list. clientId maps to the dispenserId.\n User account setup and sign-inCognito sign-up and sign-in calls are made. When signing in, the app calls the GetResources method which checks if the authenticated user has a resources entry in the database. If it does, the values are returns. If not, it immediately returns a message so the app can request the CreateResources method. This method executes the following to create the resources:\nCheck if at limit for workshopUse username to create IAM user and credentialsCreate thing, certificate, attach to policycreate Cloud9 instance for userUpdate DynamoDB with the contents And after creation the values are returned within a 25 second period. The application should set a notice to the user that assets are being created and to wait.\nFigure 1. User Sign-up and Sign-in Flow Testing Lambda FunctionsFrom the cdd/ directory, use the following sam local command on the test events in tests/:\n$ sam local invoke \u0026quot;FunctionName\u0026quot; -e event.json $ # Or to use a specific profile $ sam local invoke --profile my-aws-profile \u0026quot;FunctionName\u0026quot; -e event.json Installing Packages for Lambda FunctionsIn order to properly operate in the Lambda runtime environment, use the following steps to include packages with proper share objects or binary components:\nIn the root of the Lambda function, execute the following, replace python version and package(s) to install: $ docker run -v \u0026quot;$PWD\u0026quot;:/var/task -it lambci/lambda:build-python3.7 /bin/bash -c \u0026quot;pip install cryptography -t .; exit\u0026quot; The /bin/bash -c \"pip install cryptography -t .; exit\" is a single line to install the packages in what is mapped to the local lambda directory. You could also use /bin/bash which will place you into the build container where the individual pip install package_name -t . lines could be processed.\n "
},
{
	"uri": "https://cdd.example.com/docs/glossary.html",
	"title": "Standardized Glossary",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://cdd.example.com/docs/_footer.html",
	"title": "",
	"tags": [],
	"description": "",
	"content": "Copyright © 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n"
},
{
	"uri": "https://cdd.example.com/docs/",
	"title": "",
	"tags": [],
	"description": "",
	"content": "Connected Drink Dispenser Workshop Welcome to the Connected Drink Dispenser Workshop!\nFrom this home page you can use the left side navigation to view the content of the workshop.\n\u0026raquo; Participants \u0026laquo; Select the Workshop Participant link to get started.\n"
},
{
	"uri": "https://cdd.example.com/docs/categories.html",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://cdd.example.com/docs/tags.html",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]